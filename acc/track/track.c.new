/****************************************************************
 This file is track.c

        Nimesh Patel
	
	This version is for the PowerPC.
	Revision date: 10 February 2000.
	This version is multithreaded.
	
	Communications to the PMAC are through ASCII DPRAM as 
	earlier, but without using the NI-VXI library calls.

	Reflective memory is accessed using C. Katz's driver.

	The GPS clock is read using P. Peterson's driver.
	
	This version is supposed to run as a daemon on antenna
	computer, started via /bin/rc, and without any display
	or keyboard interactions. All data are monitored via
	reflective memory or RPC and all commands are via SMAsh
	(reflective memory).

	Added one more thread for ccdClient. 22 Apr 00.

	4 May 2000:
	Added in parts from the haystack version for antenna-1
	to interface with Bob Wilson's servo code using shared
	memory. Removed all the PMAC stuff.

	23 Sep 2002:
	Got rid of all the PMAC stuff (even though they were within #if 0 blocks)

*****************************************************************/
#include <stdio.h>
#include <sys/utsname.h>
#include <signal.h>
#include <fcntl.h>
#include <unistd.h>
#include <smem.h>
#include <math.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/file.h>
#include <termio.h>
#include <time.h>
#include <resource.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <termios.h>
#include <pthread.h>
#include <rpc/rpc.h>
#include <smapopt.h>
#include "novas.h"
#include "track.h"
#include "vme_sg_simple.h"
#include "syncclock32.h"
#include "rm.h"
#include "acu.h"
#include "ccd.h"
#include "tsshm.h"
#include "optics.h"
#include "tune.h"
#include "rxTuningCodes.h"
#include "smadaemon.h"
#include "../../iPOctal232/includeFiles/iPOctal232.h"
#include "commonLib.h"
#include "stderrUtilities.h"

#define ACUPMAC 0
#define SUBREFLECTOR_BEEP 0
#define DEBUG 0
#define COORDINATES_SVC 1
#define PMAC_HANDSHAKE_FLAG_OFFSET 0x88d
#define CCD_BIAS 130
#define CCD_GAIN 120
#define T1950   2433281.0
#define T2000   2451544.0

#define MSEC_PER_DEG 3600000.
#define MSEC_PER_HR 3600000.      
#define AUPERDAY_KMPERSEC 1731.45717592 

#define	HIGH_EL_TO_AVOID_SUN_MAS 288000000. 
#define	LOW_EL_TO_AVOID_SUN_MAS 54000000.

#define IDLE_DRIVES_TIMEOUT 300 

/************************************************************************/
struct source
{
    char            sourcename[20], veltype[20], comment[100], decsign;
    int             rah, ram, decd, decm;
    float           ras, decs, epoch, vel, pmr, pmd;
};

/************************ Function declarations *************************/
void handlerForSIGINT(int signum);
/*
int ccdprog_1(char* host);
*/
void *CommandHandler();
void *tuneClient();
void reportOpticsResults(opticsStatus *results);
/*
void *CCDClient();
*/
void SendMessageToRM(char *messg);
void SendLastCommandToRM(char *lastCommand);       
void            local(double *lst, double *ra, double *dec, double *az, double *el, double *tjd, double *azoff, double *eloff, float *pressure, float *temperature, float *humidity, int *radio_flag, float *refraction, float *pmdaz, float *pmdel,  short *target_flag, double *commanded_az,double *commanded_el);

void            split(unsigned long * lw, unsigned short * sw1, unsigned short * sw2);

void            print_upper(char *name);
void            pad(char *s, int length);
void            is_planet(char *s, int *flag, int *id);
void            starcat(char *s, int *star_flag, struct source * observe_source);
void sidtim(double *tjdh,double *tjdl,int *k,double *gst);
double sunDistance(double az1,double el1,double az2,double el2);
double tjd2et(double tjd);


/** Global variables *********************************************** */


struct sigaction action, old_action;
int sigactionInt;

pthread_t	CommandHandlerTID, CCDClientTID ;
pthread_t	tuneClientTID;
	struct sched_param param;
	pthread_attr_t *attr,*attr2,*attr3,*attr4,*attr5;
	int policy = SCHED_FIFO;

unsigned short         *pmac_ptr;
unsigned long   window;
int pmacOut;

	int antlist[RM_ARRAY_SIZE],rm_status;

int	first_time_spk=1; /* this variable is used for opening the 
		ephemeris file only once, on  first pass */

int             user;  /* input command */ 

char            messg[100];
char            lastCommand[100];
short pmac_command_flag=0;
char            sptype[10]="----------";
float           magnitude=0.;
int             read_mount_model_flag = 1;
double		azmodelrms,elmodelrms,azdc,azcol,eltilt,aztilt_sin,aztilt_cos,aztilt_sin2,aztilt_cos2,
		azenc_sin,azenc_cos,azenc_sin2,azenc_cos2,
		azenc_sin3,azenc_cos3,
                eldc,elsag,eaztilt_sin,eaztilt_cos,eaztilt_sin2,eaztilt_cos2;
double		razmodelrms,relmodelrms,razdc,razcol,reltilt,raztilt_sin,raztilt_cos,raztilt_sin2,
		raztilt_cos2, reldc,relsag,reaztilt_sin,reaztilt_cos,
		razenc_sin,razenc_cos,razenc_sin2,razenc_cos2,
		razenc_sin3,razenc_cos3, reaztilt_sin2,reaztilt_cos2;
short 		interrupt_command_flag=0;

double 	radian;

int	acquireImageFlag=0;
int 	antennaNumber=1;

TrackServoSHM *tsshm;    /* Local pointer to shared memory for
                                    communicating az,el and rates to
                                    the dmytrack thread */

double subx_counts=0.,suby_counts=0.,focus_counts=0.,subtilt_counts=0.;
char 		pmac_command[159];
char 		pmaccommand[159];

int	tuneCommandFlag=0;
int	cal_flag=0;

    int             radio_flag=1;

	double sourceVelocity=0.;

	double subtilt_arcseconds=0.;

	int receivedSignal=0;

	double polar_dut;

	double setFeedOffsetA1=0.,setFeedOffsetA2=0.;

	int chopperYZCorrFlag=0;
	float chopperYCorrection, chopperYZCorrection[4];

	/* default pad-1 */
	double LONGITUDE_HOURS = -10.365168199815;
	double LATITUDE_DEGREES =   19.824205263889;
	double LONGITUDE_DEGREES =   -155.477522997222;
	double SINLAT =   0.339135375955;
	double COSLAT =   0.940737581250;
	double LONGRAD =   -2.713594689147;
	double HEIGHT_M =   4083.948144000000;

	char operatorErrorMessage[MAX_OPMSG_SIZE+1];

	double tiltCoefficients[6],tiltxdc,tiltydc,tiltx,tilty;
	double scaledTiltx,scaledTilty;
	short tiltflag=0;
	double tiltAzoffCorrection=0.0;
	double tiltEloffCorrection=0.0;

/*end of global variables***************************************************/

void
main(int argc, char *argv[])
{

    FILE            *fp_mount_model,*fp_tilt,*fp_tiltdc,*fp_polar;
/*debug
	FILE		*fp_debug;
*/

/*
	smapoptContext optCon;
	char smapoptc;
	struct  smapoptOption optionsTable[] = {
                {"display",'d',SMAPOPT_ARG_NONE,0,'d'},
                {"keys",'k',SMAPOPT_ARG_NONE,0,'k'},
                {NULL,0,0,NULL,0}
        };
*/


    double          ra, dec, lst, lst_prev, lst_radian, lst_radian_prev;

    double          ra_cat, dec_cat, pra, pdec, rvel;
    double 	    cmdpmra=0.0,cmdpmdec=0.0;

    double          azoff = 0.0;

    double          eloff = 0.0;

    float           pressure, humidity, temperature;
    float           windspeed, winddirection;

    float           epoch=2000.;

    double          ra0, dec0,radialVelocity0,radialVelocity;

    double          radot, decdot,radialVelocitydot;
	double		radot_prev=0.0;
	double		decdot_prev=0.0;	
	int 	radec_offset_flag=0;

    double          tjd_prev, et_prev, ra_prev, dec_prev,radialVelocity_prev;

    /* PMAC handshake flag is checked if pmac_comm = 1 */
    unsigned short  pmac_comm;

    double          tjd, tjd0, tjdn;

    double          az, el, azrate=0., elrate=0., az1, el1 ;

    double          pi, secunit, milliarcsec;

    double          hr;

    int             i;

    int             azint, elint, tjdint, azrateint, elrateint;

    int             icount = 0, app_pos_flag = 0;

    short           ret;

    double          hour_angle, hangle1, hangle2;

    short int       hangleint;

    int             nplanet;

    /* The following variables are defined for time calculations */
 int              hours, minutes;	
	double seconds,et,delta=0.,utcsec;

    /* Variables for LST calculation */
    double          d1, dtupi, gst;

    /* variables for actual az */
    double          az_actual, el_actual;
    double          az_actual_disp, el_actual_disp;

    /* end of time variables definitions */

    /* variables used for display part */
    double          lst_disp, ra_disp, dec_disp, ra_cat_disp, dec_cat_disp;

    double          az_disp, el_disp, utc_disp;
    float          az_disp_rm, el_disp_rm;

    double             tjd_disp;

    int             initflag = 0;

    /* source counter */
    int             source = 0;

    int             source_skip_flag = 1;

    /* tiltmeter */
/*
        FILE *fp_padid;
*/
        int     padid=0;
	char line[BUFSIZ];

    double          tiltxbase,tiltybase;
	double	tilta11,tilta12,tilta21,tilta22;
    float	    tilt[6];

    /* the following variables are from name.c */
    char            sname[34]="----------------------------------";
    char            sname2[34]="----------------------------------";

    int             sol_sys_flag, id, star_flag;

    struct source   observe_source;

    /* scan flags */
    int             azscan_flag = 0, elscan_flag = 0;
    int             position_switching_flag = 0;
    int             on_source = 0, off_source = 0;
    int             on_source_timer = 0, off_source_timer = 0;

    double          scan_unit = 1.;



    double          Az_cmd, El_cmd, Az_cmd_rate, El_cmd_rate;

    int             az_cmd, el_cmd;

    double          az_actual_msec, el_actual_msec;

    unsigned long          az_actual_msec_int, el_actual_msec_int;

    double          posn_error, az_error, el_error;

    double          syncdet_disp=0.0, total_power_disp=0.0;

    /* for weather parameters */

    short           azoff_int, eloff_int;

    /* integration time for ncam */
    int             integration = DEFAULT_INTEGRATION_TIME;
    short           int integration_short;

    /* for time stamping the fits images */
    time_t          time1;
    struct tm      *tval;


    float           pmdaz, pmdel, refraction;
	double		drefraction;

    short            source_on_off_flag = INVALID;
    char            previous_source_on_off_flag = INVALID;
    char            spectrometer, send_spectrometer_interrupt;

    /* tracking error smoothing */
    double          tracking_error, tracking_error_accum = 0.0, tracking_error_buffer[SMOOTH_LENGTH],
                   *dp, smoothed_tracking_error = 0.0;
    int             off_position_counter = 0, off_position_sign;

    short           target_flag = 0;
    double          commanded_az=0., commanded_el=15.;
    float          smarts_az, smarts_el;


	short scan_unit_int;

	short errorflag=OK;
	short waitflag=0;
	unsigned short slength;

	/* for system temperature */
	double tsys,hot_load_volts=0.0,sky_volts=0.0;
	double tsys2,hot_load_volts2=0.0,sky_volts2=0.0;
	short cal_wheel_status=0;
	
	double az_actual_corrected;

double et_prev_big_time_step=0.,et_time_interval;

	
/*	tilt_record_flag for writing the tilt data into a file */

	short tilt_record_flag=0;

	char tilt_timestamp[20];

/* for sun avoidance: */
	
	double sunaz,sunel;
	int suneloff=0;
	short sun_avoid_flag=0;

/* for IRIG device driver*/
	/*
	int device_fd, irig_status;
	short irig_status_s;
	POS_TIME pt_struct;
	SMA_PT sma_struct;
	DAY_TYPE julianDay;
	*/
	
	int device_fd,irig_status;
	struct vme_sg_simple_time ts;
	struct sc32_time sctime;
	int sc32fd;


/* for earthtilt and sidereal_time */
	double equinoxes,tjd_upper,tjd_lower,dpsi,deps,tobl,mobl;
	
	float sunazf, sunelf;
	float az_tracking_error,el_tracking_error;
	short dummyshortint;
	float dummyFloat;
	double dummyDouble;
	char dummyByte;
	double hourangle;
	body Planet;
	body earth = {0, 399, "earth"};
/*
The following was commented out on 11 sep 2003; this was the cause of
creating topocentric calculation error. the integer code 3 for Earth 
should have been 399.
	body earth = {0, 3, "earth"};
*/
	cat_entry star = {"cat","star",0,0.,0.,0.,0.,0.,0.};
	double distance=0.;
	/* planet radii from explanatory supplement physical ephemeredis*/
	double planetradius[11]={0.0,2439.7,6501.9,3200.0,3397.0,71492.0,
			60268.0, 25559.0,24764.,1151.0,1738.0};

	double planetradius301=1738.; /* Moon radius in km*/
	double planetradius501=1820.; /* io radius in km*/
	double planetradius502=1565.; /* europa radius in km*/
	double planetradius503=2634.; /* ganymede radius in km*/
	double planetradius504=2403.; /* callisto radius in km*/
	double planetradius601=200.; /* mimas radius in km*/
	double planetradius602=250.; /* enceladus radius in km*/
	double planetradius603=530.; /* tethys radius in km*/
	double planetradius604=560.; /* dione radius in km*/
	double planetradius605=764.; /* rhea radius in km*/
	double planetradius606=2575.; /* titan radius in km*/
	double planetradius607=145.; /* hyperion radius in km*/
	double planetradius608=718.; /* iapetus radius in km*/

	double planetradius801=1352.6; /* triton radius in km*/
	double planetradius802=170.; /* nereid radius in km */
	double planetradius375=474.; /* ceres radius in km */
	double planetradius376=266.; /* pallas radius in km */
	double planetradius377=203.6; /* hygiea radius in km */
	double planetradius378=265.; /*vesta radius in km */
	/* the above two comet radii are arbitrary- just to avoid junk
	 values for angular diameter*/

	double planetdistance=0.;
	double planetdiameter=0.;
	int beep_flag=0;

	float az_actual_corrected_rm,el_actual_disp_rm;

	struct utsname unamebuf;

 	/* for getting the system time to find the year */
	/* defined in vme_sg.h */
	/*
	YEAR_TYPE year;	
	*/

	/* for ccd image header */
	char snamefits[100];
	short int bias,gain;
	
	float lst_disp_float, utc_disp_float;

	int scbComm=0;
        int az_enc,el_enc;

        int milliseconds;
	int servomilliseconds;
	int checkmsec;
	double dmilliseconds;

        int servoOnFlag=0;

        int az_offset_flag=0;
        int el_offset_flag=0;

        double prev_azrate = 0.;
        double prev_elrate = 0.;
                                      
	char antdir[10];
	
	int azelCommandFlag=0;

	double pos1950[3],pos2000[3];

	 /* timestamp for ders */
        int timestamp;
	int	syncdet2timeStamp;
	int	syncdet2StaleFlag=0;

	float ambient_load_temperature;
	
	int subcorflag=0; /* whether to correct subref Y,Z vs el */

	char tiltfilename[30];

	double museconds;
	
	int polar_mjd;
	double polar_dx,polar_dy;

	
	int idleDrivesTimeoutFlag=0,idleDrivesTimeout=0;

/*
	short m3State;
	short m3StatePrev;
	int m3StateSetFlag=0;
*/
	short padid_disp=0;

	double raOffset=0.0;
	double decOffset=0.0;
	double cosdec=1.0;

	char modeldate[10];
	char rmodeldate[10];

	double chartTotalPowerVolts[6];
	double chartSyncdetVolts[6];
	double syncdetChannels[2];
	float	contDetMuWatt[2];

	char newCmdSourceName[34];
	int newSourceFlag=0;


	/* feedOffset terms*/
	FILE *fp_feedOffsets;
	int rxFrequency=0;
	int requestedFeed=230;
	double feedOffsetA1=0.,feedOffsetA2=0.;
	double feedOffset230A1=0.,feedOffset230A2=0.;
	double feedOffset345A1=0.,feedOffset345A2=0.;
	double feedOffset400A1=0.,feedOffset400A2=0.;
	double feedOffset690A1=0.,feedOffset690A2=0.;

        site_info location = {LATITUDE_DEGREES,LONGITUDE_DEGREES,HEIGHT_M,0.0,0.0};       

	int corruptedMountModelFile=0;
	int end_of_file=0;

	char junkstring[256];
	
	short disableDrivesFlag=0;
	
    /* END OF VARIABLE DECLARATIONS */

    /********Initializations**************************/

/* for stderr buffering- see smainit docs */

DAEMONSET

	 /* First of all, find out if some other instance of
         Track is running */
        if(processPresent("excl_Track"))
        {
        fprintf(stderr,"Track is already running - goodbye.\n");
        exit(1);
        }

/*
	This was hanging up the cpu on giving the resume command.
	Perhaps, all threads should not be at 50.
*/
	setpriority(PRIO_PROCESS,0,50);

    pi = 4.0 * atan(1.0);
    dtupi = pi * 2.0;
    radian = pi / 180.;
    secunit = 1.15740741e-5;	/* day in one second */
    milliarcsec = 180. / pi * 3600000.;


	 /* signal handler for control C */
        action.sa_flags=0;
        sigemptyset(&action.sa_mask);
        action.sa_handler = handlerForSIGINT;
        sigactionInt = sigaction(SIGINT,&action, &old_action);
        sigactionInt = sigaction(SIGTERM,&action, &old_action);




	/* get the antenna number by identifying the host computer*/
	uname(&unamebuf);
	if(!strcmp(unamebuf.nodename,"acc1")) antennaNumber=1;
	if(!strcmp(unamebuf.nodename,"acc2")) antennaNumber=2;
	if(!strcmp(unamebuf.nodename,"acc3")) antennaNumber=3;
	if(!strcmp(unamebuf.nodename,"acc4")) antennaNumber=4;
	if(!strcmp(unamebuf.nodename,"acc5")) antennaNumber=5;
	if(!strcmp(unamebuf.nodename,"acc6")) antennaNumber=6;
	if(!strcmp(unamebuf.nodename,"acc7")) antennaNumber=7;
	if(!strcmp(unamebuf.nodename,"acc8")) antennaNumber=8;

/*
	if((antennaNumber==2)||(antennaNumber==3))
	{
	fprintf(stderr,"This program cannot run on antennas 2 and 3. Use \"track\".\n");
	exit(QUIT_RTN);
	}
*/



	/* initializing the IRIG board */
	  /* get the year from the system time and set it on the
                IRIG device driver */

	sc32fd = open("/dev/syncclock32",O_RDWR,0);
	if(sc32fd<=0) {
	device_fd = open("/dev/vme_sg_simple", O_RDWR,0);     
	   if(device_fd==-1) { 
	   	perror("open()");
		fprintf(stderr,"Could not open vme_sg_simple device");
		exit(SYSERR_RTN);
	   }
        }



	/*
	irig_status = ioctl(device_fd, SET_YEAR, &year);
	*/

        /* initializing ref. mem. */
        rm_status=rm_open(antlist);
        if(rm_status != RM_SUCCESS) {
                rm_error_message(rm_status,"rm_open()");
		fprintf(stderr,"Could not open reflective memory.");
                exit(QUIT_RTN);
        }

	/* start listening to ref. mem. interrupts for SMAsh commands*/
	rm_status=rm_monitor(RM_ANT_0,"RM_SMARTS_PMAC_COMMAND_FLAG_S");
                if(rm_status != RM_SUCCESS) {
                rm_error_message(rm_status,"rm_monitor()");
                exit(1);
                }
 
	/* starting the command handler thread */
	/* The following is the old Posix.4a way of 
	   doing threads*/
	/*
	if (pthread_attr_create(attr) == -1 ) {
	perror("main: pthread_attr_create attr");
	exit(-1);
	}
	pthread_attr_setinheritsched (&attr, PTHREAD_DEFAULT_SCHED);
	pthread_attr_setprio(&attr,16);
	pthread_attr_setsched(&attr, SCHED_FIFO);
	*/

	/* This is the new way in Posix.1c
	in LynxOS3.1.0a*/
	pthread_attr_init(attr);
	if (pthread_create(&CommandHandlerTID, attr, CommandHandler,
			 (void *) 0) == -1) { 
	perror("main: pthread_create CommandHandler");
	exit(-1);
	}
	param.sched_priority=18;
	pthread_attr_setschedparam(&attr,&param);
	pthread_setschedparam(CommandHandlerTID,policy,&param);

	/* starting the ccd client thread */
/*
	pthread_attr_init(attr2);
	if (pthread_create(&CCDClientTID, attr2, CCDClient,
			 (void *) 0) == -1) { 
	perror("main: pthread_create CCDClient");
	exit(-1);
	}
	param.sched_priority=18;
	pthread_attr_setschedparam(&attr2,&param);
	pthread_setschedparam(CCDClientTID,policy,&param);
*/

	/* starting the tune client thread */
	pthread_attr_init(attr5);
	if (pthread_create(&tuneClientTID, attr5, tuneClient,
			 (void *) 0) == -1) { 
	perror("main: pthread_create tuneClient");
	exit(-1);
	}
	param.sched_priority=17;
	pthread_attr_setschedparam(&attr5,&param);
	pthread_setschedparam(tuneClientTID,policy,&param);

    /* tracking smoothing error */

    for (i = 0; i < SMOOTH_LENGTH; i++)
	tracking_error_buffer[i] = 0.0;
    dp = tracking_error_buffer;

    /*
     * setting these proper-motion and radial vel terms to zero for now
     */
    pra = 0.0;
    pdec = 0.0;
    rvel = 0.0;

    /*************************************************/

	pmac_comm = 0;

	radio_flag=1;

    /**********************************************/
	     

/*debug 
fp_debug=fopen("/instance/track.debug.dat","a");
    if (antennaNumber==4) {
	fp_debug=fopen("./ant4.debug.dat","a"); 
	}
    if (antennaNumber==5) {
	fp_debug=fopen("./ant5.debug.dat","a"); 
	}
*/

    /* mount model parameters*/

	fp_mount_model=fopen("/instance/lib/mountModels/mount.model","r"); 
        fp_tiltdc=fopen("/instance/lib/tiltConstants/tiltCoefficients","r"); 

	if(fp_mount_model==NULL) {
	fprintf(stderr,"Failed to open the mount model file.\n");
	exit(QUIT_RTN);
	}
	if(fp_tiltdc==NULL) {
	fprintf(stderr,"Failed to tiltConstants file.\n");
	exit(QUIT_RTN);
	}
    /***********************************************/

    /* read mount model parameters */
	end_of_file=0;
	corruptedMountModelFile=0;
	if(read_mount_model_flag==1)
	{
	end_of_file=fscanf(fp_mount_model,"%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %s",&azdc,&azcol,&eltilt,&aztilt_sin,&aztilt_cos,&aztilt_sin2,&aztilt_cos2, 
&azenc_sin,&azenc_cos,&azenc_sin2,&azenc_cos2,&azenc_sin3,&azenc_cos3,
&azmodelrms,&eldc,&elsag,&eaztilt_sin,&eaztilt_cos,&eaztilt_sin2,&eaztilt_cos2,&elmodelrms,modeldate);
	if(end_of_file!=22) corruptedMountModelFile=1;
	end_of_file=fscanf(fp_mount_model,"%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %s",&razdc,&razcol,&reltilt,&raztilt_sin,&raztilt_cos,&raztilt_sin2,&raztilt_cos2, 
&razenc_sin,&razenc_cos,&razenc_sin2,&razenc_cos2,&razenc_sin3,&razenc_cos3,
&razmodelrms,&reldc,&relsag,&reaztilt_sin,&reaztilt_cos,&reaztilt_sin2,&reaztilt_cos2,&relmodelrms,rmodeldate);
	if(end_of_file!=22) corruptedMountModelFile=1;
	end_of_file=fscanf(fp_mount_model,"%s",junkstring);
	if(end_of_file>0) corruptedMountModelFile=1;
	read_mount_model_flag=0;
	}
	fclose(fp_mount_model);
	if(corruptedMountModelFile==1) {
	strcpy(messg, "Mount model file is corrupted.");
        SendMessageToRM(messg);
        fprintf(stderr,"%s\n",messg);
        strcpy(operatorErrorMessage, "Mount model file is corrupted.");
          sendOpMessage(OPMSG_WARNING, 10, 30, operatorErrorMessage);
	exit(QUIT_RTN);
	}

/*
printf("%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %s",
razdc,razcol,reltilt,raztilt_sin,raztilt_cos,raztilt_sin2,raztilt_cos2,
razenc_sin,razenc_cos,razenc_sin2,razenc_cos2,razenc_sin3,razenc_cos3,
razmodelrms,reldc,relsag,reaztilt_sin,reaztilt_cos,reaztilt_sin2,reaztilt_cos2,relmodelrms,rmodeldate);
*/

   /* read the tiltmeter dc offsets from tilt.dc file */

	fscanf(fp_tiltdc,"%lf %lf %lf %lf %lf %lf",&tiltxdc,&tiltydc,&tilta11,
		&tilta12,&tilta21,&tilta22);
	tiltCoefficients[0]=tiltxdc;
	tiltCoefficients[1]=tiltydc;
	tiltCoefficients[2]=tilta11;
	tiltCoefficients[3]=tilta12;
	tiltCoefficients[4]=tilta21;
	tiltCoefficients[5]=tilta22;
	fclose(fp_tiltdc);

   /* receiver feed offsets coefficients for pointing corrections */

        fp_feedOffsets = fopen("/instance/configFiles/feedOffsets","r");
        if(fp_feedOffsets==NULL) {
        fprintf(stderr,"Failed to open the feedOffsets file.\n");
        exit(QUIT_RTN);
        }
        while(fgets(line,sizeof(line),fp_feedOffsets) != NULL) {
        line[strlen(line)-1]='\0';
                if(line[0]!='#')
                {
                sscanf(line,"%d %lf %lf",&rxFrequency,&feedOffsetA1,&feedOffsetA2);
	        if(rxFrequency == 230) {
			feedOffset230A1=feedOffsetA1;
			feedOffset230A2=feedOffsetA2;
	        }
	        if(rxFrequency == 345) {
			feedOffset345A1=feedOffsetA1;
			feedOffset345A2=feedOffsetA2;
	        }
	        if(rxFrequency == 400) {
			feedOffset400A1=feedOffsetA1;
			feedOffset400A2=feedOffsetA2;
	        }
	        if(rxFrequency == 690) {
			feedOffset690A1=feedOffsetA1;
			feedOffset690A2=feedOffsetA2;
	        }
                }
        }
        fclose(fp_feedOffsets);

	setFeedOffsetA1=0.;
	setFeedOffsetA2=0.;

        rm_status=rm_read(RM_ANT_0,"RM_FEED_L",&requestedFeed);
	if(requestedFeed==230) {
	setFeedOffsetA1=feedOffset230A1;
	setFeedOffsetA2=feedOffset230A2;
	}
	if(requestedFeed==345) {
	setFeedOffsetA1=feedOffset345A1;
	setFeedOffsetA2=feedOffset345A2;
	}
	if(requestedFeed==400) {
	setFeedOffsetA1=feedOffset400A1;
	setFeedOffsetA2=feedOffset400A2;
	}
	if(requestedFeed==690) {
	setFeedOffsetA1=feedOffset690A1;
	setFeedOffsetA2=feedOffset690A2;
	}

	rm_status=rm_write(RM_ANT_0,"RM_FEEDOFFSET_A1_ARCSEC_D",
		&setFeedOffsetA1);
	rm_status=rm_write(RM_ANT_0,"RM_FEEDOFFSET_A2_ARCSEC_D",
		&setFeedOffsetA2);


/*debug
fprintf(stderr,"Read these feedOffset terms:\n");
fprintf(stderr,"230: %lf %lf\n",feedOffset230A1,feedOffset230A2);
fprintf(stderr,"345: %lf %lf\n",feedOffset345A1,feedOffset345A2);
fprintf(stderr,"690: %lf %lf\n",feedOffset690A1,feedOffset690A2);
*/


  /****************************************************/
    /*
     * This is to get the user input as a single unbuffered char and
     * zero-wait
     */

	 tsshm = OpenShm(TSSHMNAME, TSSHMSZ);    


	/* Now check if servo is running */
	 checkmsec=tsshm->msec;
	usleep(100000);
	if((tsshm->msec)==checkmsec) {
	fprintf(stderr,"Warning: Servo is not running.\n");
	}

	padid=tsshm->padID;

	switch (padid) {
	case 1:
	LONGITUDE_HOURS = -10.365168199815;
	LATITUDE_DEGREES =   19.824205263889;
	LONGITUDE_DEGREES =   -155.477522997222;
	SINLAT =   0.339135375955;
	COSLAT =   0.940737581250;
	LONGRAD =   -2.713594689147;
	HEIGHT_M =   4083.948144000000;
	break;
	case 2:
	LONGITUDE_HOURS = -10.365172952407;
	LATITUDE_DEGREES =  19.824152547222;
	LONGITUDE_DEGREES =  -155.477594286111;
	SINLAT =  0.339134510401;
	COSLAT =  0.940737893281;
	LONGRAD =  -2.713595933373;
	HEIGHT_M =  4083.942048000000;
	break;
	case 3:
	LONGITUDE_HOURS = -10.365183320370;
	LATITUDE_DEGREES =  19.824130977778;
	LONGITUDE_DEGREES =  -155.477749805556;
	SINLAT =  0.339134156253;
	COSLAT =  0.940738020951;
	LONGRAD =  -2.713598647699;
	HEIGHT_M =  4083.887184000000;
	break;
	case 4:
	LONGITUDE_HOURS = -10.365184208333;
	LATITUDE_DEGREES =  19.824217708333;
	LONGITUDE_DEGREES =  -155.477763125000;
	SINLAT =  0.339135580280;
	COSLAT =  0.940737507591;
	LONGRAD =  -2.713598880167;
	HEIGHT_M =  4083.911568000000;
	break;
	case 5:
	LONGITUDE_HOURS = -10.365180279630;
	LATITUDE_DEGREES =  19.824355391667;
	LONGITUDE_DEGREES =  -155.477704194444;
	SINLAT =  0.339137840897;
	COSLAT =  0.940736692636;
	LONGRAD =  -2.713597851635;
	HEIGHT_M =  4083.871944000000;
	break;
	case 6:
	LONGITUDE_HOURS = -10.365174633333;
	LATITUDE_DEGREES =  19.824322811111;
	LONGITUDE_DEGREES =  -155.477619500000;
	SINLAT =  0.339137305958;
	COSLAT =  0.940736885483;
	LONGRAD =  -2.713596373438;
	HEIGHT_M =  4083.935952000000;
	break;
	case 7:
	LONGITUDE_HOURS = -10.365180983333;
	LATITUDE_DEGREES =  19.824063188889;
	LONGITUDE_DEGREES =  -155.477714750000;
	SINLAT =  0.339133043229;
	COSLAT =  0.940738422193;
	LONGRAD =  -2.713598035864;
	HEIGHT_M =  4083.847560000001;
	break;
	case 8:
	LONGITUDE_HOURS = -10.365208855370;
	LATITUDE_DEGREES =  19.824006072222;
	LONGITUDE_DEGREES =  -155.478132830556;
	SINLAT =  0.339132105431;
	COSLAT =  0.940738760266;
	LONGRAD =  -2.713605332746;
	HEIGHT_M =  4080.738600000000;
	break;
	case 9:
	LONGITUDE_HOURS = -10.365211486296;
	LATITUDE_DEGREES =  19.824255827778;
	LONGITUDE_DEGREES =  -155.478172294444;
	SINLAT =  0.339136206161;
	COSLAT =  0.940737281961;
	LONGRAD =  -2.713606021521;
	HEIGHT_M =  4079.162784000000;
	break;
	case 10:
	LONGITUDE_HOURS = -10.365200670556;
	LATITUDE_DEGREES =  19.824610708333;
	LONGITUDE_DEGREES =  -155.478010058333;
	SINLAT =  0.339142032926;
	COSLAT =  0.940735181389;
	LONGRAD =  -2.713603189967;
	HEIGHT_M =  4077.266928000000;
	break;;
	case 11:
	LONGITUDE_HOURS = -10.365185401481;
	LATITUDE_DEGREES =  19.824517377778;
	LONGITUDE_DEGREES =  -155.477781022222;
	SINLAT =  0.339140500538;
	COSLAT =  0.940735733825;
	LONGRAD =  -2.713599192533;
	HEIGHT_M =  4078.818360000000;
	break;
	case 12:
	LONGITUDE_HOURS = -10.365202354444;
	LATITUDE_DEGREES =  19.823823244444;
	LONGITUDE_DEGREES =  -155.478035316667;
	SINLAT =  0.339129103582;
	COSLAT =  0.940739842413;
	LONGRAD =  -2.713603630808;;
	HEIGHT_M =  4081.201896000000;
	break;
	case 13:
	LONGITUDE_HOURS = -10.365283378704;
	LATITUDE_DEGREES =  19.823676175000;
	LONGITUDE_DEGREES =  -155.479250680556;
	SINLAT =  0.339126688847;
	COSLAT =  0.940740712902;
	LONGRAD =  -2.713624842909;
	HEIGHT_M =  4072.463280000000;
	break;;
	case 14:
	LONGITUDE_HOURS = -10.365281998889;
	LATITUDE_DEGREES =  19.824235750000;
	LONGITUDE_DEGREES =  -155.479229983333;
	SINLAT =  0.339135876505;
	COSLAT =  0.940737400802;
	LONGRAD =  -2.713624481675;
	HEIGHT_M =  4072.493760000000;
	break;;
	case 15:
	LONGITUDE_HOURS = -10.365255227593;
	LATITUDE_DEGREES =  19.825280033333;
	LONGITUDE_DEGREES =  -155.478828413889;
	SINLAT =  0.339153022500;
	COSLAT =  0.940731219493;
	LONGRAD =  -2.713617472966;
	HEIGHT_M =  4072.173720000000;
	break;
	case 16:
	LONGITUDE_HOURS = -10.365213732037;
	LATITUDE_DEGREES =  19.825068244444;
	LONGITUDE_DEGREES =  -155.478205980556;
	SINLAT =  0.339149545166;
	COSLAT =  0.940732473136;
	LONGRAD =  -2.713606609455;
	HEIGHT_M =  4073.109456000000;
	break;
	case 17:
	LONGITUDE_HOURS = -10.365253228148;
	LATITUDE_DEGREES =  19.823238797222;
	LONGITUDE_DEGREES =  -155.478798422222;
	SINLAT =  0.339119507521;
	COSLAT =  0.940743301660;
	LONGRAD =  -2.713616949512;
	HEIGHT_M =  4073.572752000000;
	break;
	case 18:
	LONGITUDE_HOURS = -10.365390733889;
	LATITUDE_DEGREES =  19.824589975000;
	LONGITUDE_DEGREES =  -155.480861008333;
	SINLAT =  0.339141692507;
	COSLAT =  0.940735304113;
	LONGRAD =  -2.713652948431;
	HEIGHT_M =  4059.262392000001;
	break;
	case 19:
	LONGITUDE_HOURS = -10.365473045370;
	LATITUDE_DEGREES =  19.825722894444;
	LONGITUDE_DEGREES =  -155.482095680556;
	SINLAT =  0.339160293764;
	COSLAT =  0.940728598021;
	LONGRAD =  -2.713674497527;
	HEIGHT_M =  4047.780576000001;
	break;
	case 20:
	LONGITUDE_HOURS = -10.365328293889;
	LATITUDE_DEGREES =  19.827237122222;
	LONGITUDE_DEGREES =  -155.479924408333;
	SINLAT =  0.339185155465;
	COSLAT =  0.940719634276;
	LONGRAD =  -2.713636601677;
	HEIGHT_M =  4065.370584000000;
	break;
	case 21:
	LONGITUDE_HOURS = -10.365214970741;
	LATITUDE_DEGREES =  19.827106916667;
	LONGITUDE_DEGREES =  -155.478224561111;
	SINLAT =  0.339183017664;
	COSLAT =  0.940720405077;
	LONGRAD =  -2.713606933747;
	HEIGHT_M =  4063.654560000000;
	break;
	case 22:
	LONGITUDE_HOURS = -10.365183302037;
	LATITUDE_DEGREES =  19.824288438889;
	LONGITUDE_DEGREES =  -155.477749530556;
	SINLAT =  0.339136741602;
	COSLAT =  0.940737088934;
	LONGRAD =  -2.713598642899;
	HEIGHT_M =  4083.920712000001;
	break;
	case 23:
	LONGITUDE_HOURS = -10.365206107963;
	LATITUDE_DEGREES =  19.824515647222;
	LONGITUDE_DEGREES =  -155.478091619444;
	SINLAT =  0.339140472124;
	COSLAT =  0.940735744068;
	LONGRAD =  -2.713604613477;
	HEIGHT_M =  4077.306552000000;
	break;
	case 24:
	LONGITUDE_HOURS = -10.365276307037;
	LATITUDE_DEGREES =  19.825196283333;
	LONGITUDE_DEGREES =  -155.479144605556;
	SINLAT =  0.339151647421;
	COSLAT =  0.940731715237;
	LONGRAD =  -2.713622991551;
	HEIGHT_M =  4072.213344000000;
	break;
	}

/*
	fprintf(stderr,"padid=%d lat=%f long=%f\n",padid,
		LATITUDE_DEGREES,LONGITUDE_DEGREES );
*/




    /********************end of initializations*******************/

	/* on first pass, make cmd posn = actual posn. */

	if(icount==0)
	{

	az_enc = tsshm->encAz;
        el_enc = tsshm->encEl;     
	az_actual=(double)az_enc/MSEC_PER_DEG;
        el_actual=(double)el_enc/MSEC_PER_DEG;       
	

	/* call local to get mount model corrections for the first
		commanded position */
	ra = 0.;
        dec = 0.;
        ra_disp = 0.;
        dec_disp = 0.;
        ra_cat_disp = 0.;
        dec_cat_disp = 0.;
        ra0 = 0.;
        dec0 = 0.;
        radot = 0.;
        decdot = 0.;
        hangle1 = 0.;
        hangle2 = 0.;
	lst_radian_prev=0;
	tjd_prev=0.;
	commanded_az=az_actual;
	commanded_el=el_actual;


	target_flag=1;
        local(&lst_radian_prev, &ra, &dec, &az, &el, &tjd_prev, &azoff,
		&eloff, &pressure, &temperature, &humidity, &radio_flag, 
		&refraction, &pmdaz, &pmdel,
		&target_flag,&commanded_az,&commanded_el);
        commanded_el = el_actual-pmdel/3600.;
	commanded_az = az_actual-pmdaz/3600./cos(commanded_el*radian);
	strcpy(sname,"target");
	} /* if icount==0 */

new_source:                    

	  /* read polar wobble parameters 
	     from the file /common/polar/polar.dat for now */

        fp_polar = fopen("/common/polar/polar.dat","r");
        if(fp_polar==NULL) {
        fprintf(stderr,"Failed to open /common/polar/polar.dat file\n");
        exit(QUIT_RTN);
        }
	fscanf(fp_polar,"%d %lf %lf %lf",
		&polar_mjd,&polar_dx,&polar_dy,&polar_dut);
	/* write them to RM */
        rm_status=rm_write(RM_ANT_0,"RM_POLAR_DX_ARCSEC_D",&polar_dx);
        rm_status=rm_write(RM_ANT_0,"RM_POLAR_DY_ARCSEC_D",&polar_dy);
        rm_status=rm_write(RM_ANT_0,"RM_POLAR_DUT_SEC_D",&polar_dut);
	fclose(fp_polar);


    print_upper(sname);

    if (target_flag==1) strcpy(sname,"target");

    if (target_flag == 0)
    {

	 strcpy(messg, "                              ");
                SendMessageToRM(messg);

	strcpy(sname2,sname);
	pad(sname, 20);

	if(newSourceFlag==0) is_planet(sname, &sol_sys_flag, &id);

	if (sol_sys_flag == 1)
	{
	  
	    nplanet = id;
	
		/* in the new ephemeris codes, moon is 10, not 301 */
		/*
		if(nplanet==301) nplanet=10;
		commented out on 11 jan 2001, now we are back to
		ansi-C codes from jpl and not using hoffman's package
		to read the jpl ephemeris files*/
	    ra_cat_disp = 0.;
	    dec_cat_disp = 0.;
	   Planet.type=0;
	   Planet.number=nplanet;
	  strcpy(Planet.name,sname);
	  strcpy(sptype,"----------");
	  sptype[9]=0x0;
	  magnitude=0.0;
	}
	if (sol_sys_flag == 0)
	{
            if(newSourceFlag==0) starcat(sname, &star_flag, &observe_source);
            if(newSourceFlag==1) star_flag=1;

	    if (star_flag == 0)
	    {
		nplanet = 0;

	/* unknown source. go into target mode with current

	position as commanded position */

	       strcpy(sname,"unknown");
		strcat(messg,"Source not found.");
                SendMessageToRM(messg);
		fprintf(stderr,"%s\n",messg);
	  strcpy(operatorErrorMessage, "Source not found.");
	  sendOpMessage(OPMSG_WARNING, 10, 30, operatorErrorMessage);

        az_enc = tsshm->encAz;
        el_enc = tsshm->encEl;
        az_actual=(double)az_enc/MSEC_PER_DEG;
        el_actual=(double)el_enc/MSEC_PER_DEG;
       /* call local to get mount model corrections for the first
                commanded position */
        ra = 0.;
        dec = 0.;
        ra_disp = 0.;
        dec_disp = 0.;
        ra_cat_disp = 0.;
        dec_cat_disp = 0.;
        ra0 = 0.;
        dec0 = 0.;
        radot = 0.;
        decdot = 0.;
        hangle1 = 0.;
        hangle2 = 0.;
        lst_radian_prev=0;
        tjd_prev=0.;
        commanded_az=az_actual;
        commanded_el=el_actual;
        target_flag=1;
        local(&lst_radian_prev, &ra, &dec, &az, &el, &tjd_prev, &azoff,
                &eloff, &pressure, &temperature, &humidity, &radio_flag,
                &refraction, &pmdaz, &pmdel,
                &target_flag,&commanded_az,&commanded_el);
        commanded_el = el_actual-pmdel/3600.;
        commanded_az = az_actual-pmdaz/3600./cos(commanded_el*radian);


	    }

	    if (star_flag == 1)
	    {
		nplanet = 0;

		if(newSourceFlag==0) {

		dec_cat = fabs(observe_source.decd) + observe_source.decm / 60. + observe_source.decs / 3600.;
	dec_cat = dec_cat + decOffset/3600.;
		cosdec=cos(dec_cat*radian);
	
		ra_cat = observe_source.rah + observe_source.ram / 60. + observe_source.ras / 3600.;
		ra_cat = ra_cat + (raOffset/3600./15.0/cosdec);

		if (observe_source.decsign == '-') dec_cat = -dec_cat;

/* if the coordinates are B1950, precess them to J2000 first*/
		epoch = observe_source.epoch;
		} /* if newSourceFlag==0; source from catalog */

		if(newSourceFlag==1) {
		rm_status=rm_read(RM_ANT_0,"RM_CMD_SOURCE_C34",newCmdSourceName);
		strcpy(sname,newCmdSourceName);
		rm_status=rm_read(RM_ANT_0,"RM_CMD_RA_HOURS_D",&ra_cat);
		rm_status=rm_read(RM_ANT_0,"RM_CMD_DEC_DEG_D",&dec_cat);
		rm_status=rm_read(RM_ANT_0,"RM_CMD_PMRA_MASPYEAR_D",&cmdpmra);
		rm_status=rm_read(RM_ANT_0,"RM_CMD_PMDEC_MASPYEAR_D",&cmdpmdec);
		rm_status=rm_read(RM_ANT_0,"RM_CMD_EPOCH_YEAR_D",&dummyDouble);
		epoch=(float)dummyDouble;
		rm_status=rm_read(RM_ANT_0,"RM_CMD_SVEL_KMPS_D",&sourceVelocity);
		strcpy(sname,newCmdSourceName);

		dec_cat =  dec_cat + decOffset/3600.;
		cosdec=cos(dec_cat*radian);
	
		ra_cat = ra_cat + (raOffset/3600./15.0/cosdec);

		}/* if source is not from catalog but given via observe command. */

		if (epoch == 1950.)
		{
			radec2vector(ra_cat,dec_cat,1.0,pos1950);
                        precession(T1950,pos1950,T2000,pos2000);
                        vector2radec(pos2000,&ra_cat,&dec_cat);

		}
		star.ra=ra_cat;
		star.dec=dec_cat;
		/* converting input pm-ra in mas/yr to sec/century */
		star.promora= cmdpmra/15./cos(dec_cat*radian)/10.;
		star.promodec=cmdpmdec/10.;
		if(newSourceFlag==1) {
		star.promora=
		 (double)observe_source.pmr/15./cos(dec_cat*radian)/10.;
		star.promodec=(double)observe_source.pmd/10.;
		}
		ra_cat_disp = ra_cat;
		dec_cat_disp = dec_cat;
	    }			/* star_flag if */
	}			/* sol_sys_flag if */
    }				/* if target flag is 0 */
/* write sol_sys_flag to RM */
        dummyshortint=(short)sol_sys_flag;
        rm_status=rm_write(RM_ANT_0,"RM_SOLSYS_FLAG_S",&dummyshortint);
        if(rm_status != RM_SUCCESS) {
                rm_error_message(rm_status,"rm_write() solsysflag");
                }







/************************************************************************/
    /* starting infinite loop */
/************************************************************************/


    /* getting previously written offsets from ref. mem. */

	rm_status=rm_read(RM_ANT_0,"RM_AZOFF_D",&azoff);	
	rm_status=rm_read(RM_ANT_0,"RM_ELOFF_D",&eloff);	
	rm_status=rm_read(RM_ANT_0,"RM_RAOFF_ARCSEC_D",&raOffset);
	rm_status=rm_read(RM_ANT_0,"RM_DECOFF_ARCSEC_D",&decOffset);


    /*
     * if offsets are huge, due to a bad initialization in ref. mem. then do
     * not use them if(fabs(azoff)>1800.) azoff=0.; if(fabs(eloff)>1800.)
     * azoff=0.;
     */

    /* On changing pmac_comm flag toggle come back here*/ 


	/* reset the pmac_command_flag to zero to begin with 
	rm_status=rm_write(RM_ANT_0,
		"RM_SMARTS_PMAC_COMMAND_FLAG_S",&pmac_command_flag);
	*/

	 strcpy(messg, "                              ");
                SendMessageToRM(messg);

    /* begin while loop every 1 second */
    while (1)
    {

beginning:
	yield();

	
	/* read the subreflector correction flag from RM */
        rm_status=rm_read(RM_ANT_0,"RM_SUBCORFLAG_L",&subcorflag);


	/* get sun's position */

	rm_status=rm_read(RM_ANT_0,"RM_SUN_AZ_DEG_F",&sunazf);
	sunaz=(double)sunazf;
	sunaz=sunaz*radian;

	rm_status=rm_read(RM_ANT_0,"RM_SUN_EL_DEG_F",&sunelf);
	sunel=(double)sunelf;
	sunel=sunel*radian;

	/* if pmac_command_flag is set, get and execute the pmac
	command*/


	rm_status=rm_read(RM_ANT_0,"RM_CALIBRATION_WHEEL_S",&cal_wheel_status);


	/* chopper YZ correction */
	rm_status=rm_read(RM_ANT_0,"RM_CHOPPER_FOCUS_CURVE_FLAG_L",&chopperYZCorrFlag);

	if(chopperYZCorrFlag==1) {
	rm_status=rm_read(RM_ANT_0,
		"RM_CHOPPER_FOCUS_CURVE_MM_V4_F",&chopperYZCorrection);
	chopperYCorrection=chopperYZCorrection[1];
	}

        rm_status=rm_read(RM_ANT_0, "RM_SYNCDET2_TIMESTAMP_L",&syncdet2timeStamp);
        rm_status=rm_read(RM_ANT_0,"RM_UNIX_TIME_L",&timestamp);
          if (syncdet2timeStamp < (timestamp-300)) syncdet2StaleFlag=1;
	  else syncdet2StaleFlag=0;

	if((cal_flag==1)&&(cal_wheel_status==1)) {
	if(syncdet2StaleFlag==0) {
        rm_status=rm_read(RM_ANT_0,"RM_CONT_DET_MUWATT_V2_F",&contDetMuWatt);
        hot_load_volts = (double) contDetMuWatt[0];
        hot_load_volts2 = (double) contDetMuWatt[1];
	} 
	if(syncdet2StaleFlag==1) {
	rm_status=rm_read(RM_ANT_0,"RM_CONT1_DET1_POWER_MUWATT_F",&dummyFloat);
  	hot_load_volts = (double) dummyFloat;
	rm_status=rm_read(RM_ANT_0,"RM_CONT1_DET2_POWER_MUWATT_F",&dummyFloat);
  	hot_load_volts2 = (double) dummyFloat;
	}

	dummyFloat=(float)hot_load_volts;
      rm_status=rm_write(RM_ANT_0,"RM_HOTLOAD_LOWFREQ_VOLTS_F",&dummyFloat);
	dummyFloat=(float)hot_load_volts2;
   rm_status=rm_write(RM_ANT_0,"RM_HOTLOAD_HIGHFREQ_VOLTS_F",&dummyFloat);
        rm_status=rm_read(RM_ANT_0,"RM_UNIX_TIME_L",&timestamp);
        rm_status=rm_write(RM_ANT_0,"RM_HOTLOAD_LOWFREQ_VOLTS_TIMESTAMP_L",
                        &timestamp);
        rm_status=rm_write(RM_ANT_0,"RM_HOTLOAD_HIGHFREQ_VOLTS_TIMESTAMP_L",
                        &timestamp);
        /* read the ambient load temperature */
        rm_status=rm_read(RM_ANT_0,"RM_AMBIENTLOAD_TEMPERATURE_F",
                                        &ambient_load_temperature);

	}

	if((cal_flag==0)&&(cal_wheel_status==0)) {

	if(syncdet2StaleFlag==0) {
        rm_status=rm_read(RM_ANT_0,"RM_CONT_DET_MUWATT_V2_F",&contDetMuWatt);
        sky_volts = (double) contDetMuWatt[0];
        sky_volts2 = (double) contDetMuWatt[1];
	}
	if(syncdet2StaleFlag==1) {
        rm_status=rm_read(RM_ANT_0,"RM_CONT1_DET1_MUWATT_F",&dummyFloat);
        sky_volts = (double) dummyFloat;
        rm_status=rm_read(RM_ANT_0,"RM_CONT1_DET2_MUWATT_F",&dummyFloat);
        sky_volts2 = (double) dummyFloat;
	}

        dummyFloat=(float)sky_volts;
        rm_status=rm_write(RM_ANT_0,"RM_SKY_LOWFREQ_VOLTS_F",&dummyFloat);
        dummyFloat=(float)sky_volts2;
        rm_status=rm_write(RM_ANT_0,"RM_SKY_HIGHFREQ_VOLTS_F",&dummyFloat);
        rm_status=rm_read(RM_ANT_0,"RM_UNIX_TIME_L",&timestamp);
        rm_status=rm_write(RM_ANT_0,"RM_SKY_LOWFREQ_VOLTS_TIMESTAMP_L",
                        &timestamp);
        rm_status=rm_write(RM_ANT_0,"RM_SKY_HIGHFREQ_VOLTS_TIMESTAMP_L",
                        &timestamp);

	}

	rm_status=rm_read(RM_ANT_0,"RM_CONT1_DET1_POWER_MUWATT_F",&dummyFloat);
	total_power_disp=(double)dummyFloat;
	rm_status=rm_read(RM_ANT_0,"RM_SYNCDET_VOLTS_D",&syncdet_disp);

	if (source_skip_flag == 1) {
	    icount = 0;
	    source_skip_flag = 0;
	    source++;
	}

	icount++;

	if ((icount % BIG_TIME_STEP) == 0) {
	    app_pos_flag = 1;
	} else {
	    app_pos_flag = 0;
	}


	/*-------------------------------time-------------------------*/

		

/*
	hr=(double)ts.hour+((double)ts.min)/60.+ 
			(((double)ts.sec +(double)ts.usec)/1.0e6)/3600.;
*/

	   if(sc32fd>0) {

		 if((irig_status = read(sc32fd, &sctime, sizeof(sctime))) < 0) {
            	fprintf(stderr, "Error %d reading Syncclock32\n", irig_status);
            	}


	    hours = sctime.hour;
	    minutes = sctime.min;
	    seconds = (double) sctime.sec;
	    museconds = (double) sctime.usec;

	   } else {


	      irig_status = read(device_fd,&ts,1);
	        if(irig_status==-1) {
		perror("read()");
		exit(-1);
	       }
 
	    hours = ts.hour;
	    minutes = ts.min;
	    seconds = (double) ts.sec;
	    museconds = (double) ts.usec;
	    }

	
	    seconds += (museconds/1.0e6);

	hr = (double)hours + ((double)minutes)/60. + seconds/3600.;
	    utc_disp = hr;
	dmilliseconds=hr * 3600000.;
	milliseconds = (int) dmilliseconds;
/* calculating julian day */
/*
	   tjd_upper=(double)julianDay-0.5;
*/


	if(sc32fd>0) {
  tjd_upper = (double)((int)(365.25*(sctime.year+4711))) +
                        (double)sctime.yday + 351.5;
	} else {
	   tjd_upper = (double)((int)(365.25*(ts.year+4711))) + 
			(double)ts.yday + 351.5;
	}

	   tjd_lower=hr/24.;

	   tjd=tjd_upper+tjd_lower;

/*
printf("tjd=%lf %d %d %d %lf \n",tjd, ts.year,hours, minutes, seconds);
*/

   utcsec = (tjd-2451545.)* 86400.0;
	
/*
	  fprintf(stderr,"The GPS (UTC) time is: %d:%d:%d:%lf\n",
		julianDay,hours,minutes,seconds);
*/


	    delta=32.184+LEAPSECONDS+polar_dut;

	    et = utcsec+delta ;


	 /* obtain equation of equinoxes which is needed for LST */
	earthtilt(tjd_upper,&mobl, &tobl, &equinoxes,&dpsi, &deps);
	sidereal_time(tjd_upper, tjd_lower,equinoxes, &gst);
	d1 = gst *dtupi / 24.+LONGRAD;
	lst_radian = fmod(d1, dtupi);
	if (lst_radian < 0.) {
	    lst_radian += dtupi;
	}
	/* converting lst to hours */
	lst = lst_radian * 24. / dtupi;
	lst_disp = lst;
	tjd_disp = tjd;

/*
printf("lst=%lf\n",lst_disp);
printf("tjd_disp=%d\n",tjd_disp);
*/


	/*--------------------end of time part------------------------*/

	/*--------------------beginning of apparent calculations------*/

	if (target_flag == 0) {

	    if ((app_pos_flag == 1) || (icount == 1))
	    {

		if (nplanet != 0)
		{
		   topo_planet(tjd, &Planet,&earth, delta, 
			&location, &ra0, &dec0, &distance,&radialVelocity0);

	/*increment ra0 and dec0 with offsets */
	dec0 = dec0 + decOffset/3600.;
	cosdec=cos(dec0*radian);
	ra0=ra0+(raOffset/3600./15.0/cosdec);
	
		radialVelocity0 *= AUPERDAY_KMPERSEC;
		}
		if (nplanet == 0)
		{
		    topo_star(tjd,&earth,delta, &star,&location, &ra0, &dec0);

		}
		if (icount == 1)
		{
		    tjd_prev = tjd - secunit * 30.;
		    et_prev = et - 30.;
		    lst_prev = lst - 8.3333333333e-3; 
		    lst_radian_prev = lst_prev * dtupi / 24.;
		    if (lst_radian_prev < 0.)
		    {
			lst_radian_prev += dtupi;
		    }
		    if (nplanet != 0)
		    {
		   topo_planet(tjd_prev, &Planet,&earth, delta, 
		&location, &ra_prev, &dec_prev, &distance,&radialVelocity_prev);
		radialVelocity_prev *= AUPERDAY_KMPERSEC;


	if(Planet.number <=11)  {
	planetdiameter=2.0*planetradius[Planet.number]/distance/149597900.0;
	} else {
	switch (Planet.number) {
	case 301:
	planetdiameter=2.0*planetradius301/distance/149597900.0;
	break;
	case 501:
	planetdiameter=2.0*planetradius501/distance/149597900.0;
	break;
	case 502:
	planetdiameter=2.0*planetradius502/distance/149597900.0;
	break;
	case 503:
	planetdiameter=2.0*planetradius503/distance/149597900.0;
	break;
	case 504:
	planetdiameter=2.0*planetradius504/distance/149597900.0;
	break;
	case 601:
	planetdiameter=2.0*planetradius601/distance/149597900.0;
	break;
	case 602:
	planetdiameter=2.0*planetradius602/distance/149597900.0;
	break;
	case 603:
	planetdiameter=2.0*planetradius603/distance/149597900.0;
	break;
	case 604:
	planetdiameter=2.0*planetradius604/distance/149597900.0;
	break;
	case 605:
	planetdiameter=2.0*planetradius605/distance/149597900.0;
	break;
	case 606:
	planetdiameter=2.0*planetradius606/distance/149597900.0;
	break;
	case 607:
	planetdiameter=2.0*planetradius607/distance/149597900.0;
	break;
	case 608:
	planetdiameter=2.0*planetradius608/distance/149597900.0;
	break;
	case 801:
	planetdiameter=2.0*planetradius801/distance/149597900.0;
	break;
	case 802:
	planetdiameter=2.0*planetradius802/distance/149597900.0;
	break;
	case 375:
	planetdiameter=2.0*planetradius375/distance/149597900.0;
	break;
	case 376:
	planetdiameter=2.0*planetradius376/distance/149597900.0;
	break;
	case 377:
	planetdiameter=2.0*planetradius377/distance/149597900.0;
	break;
	case 378:
	planetdiameter=2.0*planetradius378/distance/149597900.0;
	break;
	}

	}
	planetdiameter=(planetdiameter/radian)*3600.;

		    } else
		    {
		    topo_star(tjd_prev,&earth,delta, &star,&location, &ra_prev, &dec_prev);
		    }
		}


		et_time_interval = et - et_prev_big_time_step;

		if(icount==1) et_time_interval=30.;


/* commented out on 12 sep 2003 suspecting error in radot decdot

		if(icount!=1)
		{
		if(et_time_interval!=0.)
		{
		if(radec_offset_flag==0) {
		radot = (ra0 - ra_prev) / et_time_interval;
		decdot = (dec0 - dec_prev) / et_time_interval;
		} else {
		radot = radot_prev;
		decdot = decdot_prev;
		radec_offset_flag=0;
		}
		radialVelocitydot=(radialVelocity0-radialVelocity_prev)/et_time_interval;
		}
		}

		if(icount==1)
		{
*/
		if(radec_offset_flag==0) {
		radot = (ra0 - ra_prev) / 30.;
		decdot = (dec0 - dec_prev) /30. ;
		} else {
		radot = radot_prev;
		decdot = decdot_prev;
		radec_offset_flag=0;
		}
		radialVelocitydot=(radialVelocity0-radialVelocity_prev)/30.;
/*
		}
*/

		    ra_prev = ra0;
		    dec_prev = dec0;
		    radot_prev=radot;
		    decdot_prev=decdot;
		    radialVelocity_prev=radialVelocity0;
		    et_prev_big_time_step=et;

		
	    }			/* ((app_pos_flag == 1) || (icount == 1)) */
	}			/* if target_flag=0 */

	/* read the weather parameters from ref. mem. */
	rm_status=rm_read(RM_ANT_0,"RM_WEATHER_TEMP_F",&temperature);
	rm_status=rm_read(RM_ANT_0,"RM_WEATHER_HUMIDITY_F",&humidity);
	rm_status=rm_read(RM_ANT_0,"RM_WEATHER_MBAR_F",&pressure);
	rm_status=rm_read(RM_ANT_0,"RM_WEATHER_WINDSPEED_F",&windspeed);
	windspeed *= 0.44704; /* convert from mph to m/s */
	rm_status=rm_read(RM_ANT_0,"RM_WEATHER_WINDDIR_F",&winddirection);

	/* read the ambient load temperature */

	rm_status=rm_read(RM_ANT_0,"RM_AMBIENTLOAD_TEMPERATURE_F",
					&ambient_load_temperature);
/*
	if((hot_load_volts>sky_volts)&&(cal_wheel_status==0))
*/
	tsys = (273.15+(double)ambient_load_temperature) 
			* (fabs(sky_volts)/(hot_load_volts-sky_volts));
	tsys2 = (273.15+(double)ambient_load_temperature) 
			* (fabs(sky_volts2)/(hot_load_volts2-sky_volts2));

/*
printf("sky_volts=%lf hot_volts=%lf load_temp=%lf tsys=%lf\n",
	sky_volts,hot_load_volts, ambient_load_temperature,tsys);
*/
	
	if(hot_load_volts==0.) tsys=0.0;
	if(tsys>99999.) tsys=99999.0;/* this is to avoid problems with display*/

	/* now pass tsys to reflective memory for monitoring*/
	rm_status=rm_write(RM_ANT_0,"RM_TSYS_D",&tsys);
	rm_status=rm_write(RM_ANT_0,"RM_TSYS2_D",&tsys2);

	/* check for limits on weather parameters */
	if (
	    (pressure < 600.) || (pressure > 1200.)
	    || (temperature < -30.) || (temperature > 70.)
	    || (humidity < 0.) || (humidity > 110.)
	    ) {
		strcpy(messg, "                                   ");
		SendMessageToRM(messg);
		strcpy(messg, "Check the weather station.");
		SendMessageToRM(messg);

	}
	/*
	 * ra and dec in hours and degrees, apparent coordinates output from
	 * stars or planets functions are converted below into azimuth and
	 * elevation. First, linearly interpolating between the ra and dec
	 * apparent positions, calculated every BIG_TIME_STEPs
	 */
	if (target_flag == 0) {
	    if(icount!=1)
            {		
	    ra = ra0 + radot * (et-et_prev_big_time_step);
	    dec = dec0 + decdot * (et-et_prev_big_time_step);
	    radialVelocity=radialVelocity0+
			radialVelocitydot*(et-et_prev_big_time_step);
            }		

	    if(icount==1)
	    {
	    ra=ra0;
	    dec=dec0;
	    radialVelocity=radialVelocity0;
	    }		

	    ra_disp = ra;
	    dec_disp = dec;

	    /* if it is a solar system object, replace
                ra_cat, dec_cat by the apparent coordinates
                instead of making them zeroes
                */

                if(sol_sys_flag==1) {
                ra_cat_disp=ra_disp;
                dec_cat_disp=dec_disp;
                }



	    ra = ra * 15.0 * pi / 180.;
	    dec = dec * pi / 180.;


	    if (icount == 1)
	    {
		tjdn = tjd - secunit;
		local(&lst_radian_prev, &ra, &dec, &az, &el, &tjd_prev, &azoff, &eloff, &pressure, &temperature, &humidity, &radio_flag, &refraction, &pmdaz, &pmdel,&target_flag,&commanded_az,
	&commanded_el);
		hangle1 = lst_radian_prev - ra;

		az1 = az;
		el1 = el;
		tjd0 = tjd;
	    }
	}			/* if target flag = 0 */

    if (target_flag == 1) {
	ra = 0.;
	dec = 0.;
	ra_disp = 0.;
	dec_disp = 0.;
	ra_cat_disp = 0.;
	dec_cat_disp = 0.;
	ra0 = 0.;
	dec0 = 0.;
	radot = 0.;
	decdot = 0.;
	strcpy(sptype, "----------");
	sptype[9]=0x0;
	magnitude=0.0;
	hangle1 = 0.;
	hangle2 = 0.;
	sol_sys_flag=0;
	local(&lst_radian_prev, &ra, &dec, &az, &el, &tjd_prev, &azoff, &eloff, &pressure, &temperature, &humidity, &radio_flag, &refraction, &pmdaz, &pmdel,&target_flag,&commanded_az,&commanded_el);
    }

	/* adding offsets for scanning/mapping */
	if (azscan_flag == 1)
	    azoff = azoff + scan_unit * TIME_STEP ;
	if (elscan_flag == 1)
	    eloff = eloff + scan_unit * TIME_STEP ;

	/* position switching */

	if (position_switching_flag == 1) {

	    if (source_on_off_flag != INVALID)
	    {
		if (on_source)
		    on_source_timer--;
		if (off_source)
		    off_source_timer--;
	    }
	    if (on_source_timer == 0)
	    {
		off_position_counter++;
		on_source = 0;
		off_source = 1;
		on_source_timer = integration * 10;
		if ((off_position_counter % 2) == 0)
		    off_position_sign = -1;
		else
		    off_position_sign = 1;
		azoff = azoff + (off_position_sign * scan_unit) ;
	        az_offset_flag=1;
		strcpy(messg, "                                       ");
		SendMessageToRM(messg);
		strcpy(messg, "position switching - OFF source");
		SendMessageToRM(messg);
		source_on_off_flag = OFFSOURCE;
		send_spectrometer_interrupt = 1;
	    }
	    if (off_source_timer == 0)
	    {
		on_source = 1;
		off_source = 0;
		off_source_timer = integration * 10;
		azoff = azoff - (off_position_sign * scan_unit);
		az_offset_flag=1;
		strcpy(messg, "                                       ");
		SendMessageToRM(messg);
		strcpy(messg, "position switching - ON source");
		SendMessageToRM(messg);
		source_on_off_flag = ONSOURCE;
		send_spectrometer_interrupt = 1;
	    }
	}


	if (target_flag == 0) {
	    local(&lst_radian, &ra, &dec, &az, &el, &tjd, &azoff, &eloff, &pressure, &temperature, &humidity, &radio_flag, &refraction, &pmdaz, &pmdel,&target_flag,&commanded_az,&commanded_el);
	    hangle2 = lst_radian - ra;
	}
	/* these variables are for the display */



	el_disp = el-pmdel/3600.*radian;
	az_disp = az-pmdaz/3600.*radian/cos(el_disp);


/* Remove the mount model from the commanded positions for display,
since these should be the true positions (also remove similarly,
for the actual positions*/

	/* Compare az_disp and el_disp with Sun's az and el
	and go into simulation mode with an error message
	if the commanded position is within SUNLIMIT degrees
	of the Sun's position */

/*
printf("sunaz=%lf sunel=%lf az_disp=%lf el_disp=%lf sundist=%lf\n",
	sunaz/radian, sunel/radian, az_disp/radian, el_disp/radian,
	sunDistance(az_disp,el_disp,sunaz,sunel));
*/

	if(sunDistance(az_disp,el_disp,sunaz,sunel)<=SUNLIMIT) {

		strcpy(lastCommand,"Standby - Sun Limit (cmd)");
		SendLastCommandToRM(lastCommand);
            	strcpy(messg, " Standing by. Sun Limit (cmd)");
		SendMessageToRM(messg);
	 } /* sun limit check  with commanded position */
	

	az_disp_rm = (float)az_disp / radian;
	el_disp_rm = (float)el_disp / radian;
	rm_status=rm_write(RM_ANT_0,"RM_COMMANDED_AZ_DEG_F",&az_disp_rm);
	rm_status=rm_write(RM_ANT_0,"RM_COMMANDED_EL_DEG_F",&el_disp_rm);

	hour_angle = hangle2 * 12.0 / pi;

	hour_angle = hour_angle * 100.;
	hangleint = (int) hour_angle;

        /* if an offset has been commanded, then add it also
        to the previous values of az and el so that the
        computed rate does not have a jump in it */

        if(az_offset_flag==0) {
		azrate = az - az1;
/* added these following two lines on 23 sep 2002 */
		if(azrate < -6.0) azrate += 2.0* pi;
		if(azrate > 6.0) azrate -= 2.0* pi;
		}

        if(az_offset_flag==1) {
        azrate = prev_azrate;
        az_offset_flag=0;
        }

        if(el_offset_flag==0) elrate = el - el1;
        if(el_offset_flag==1) {
        elrate = prev_elrate;
        el_offset_flag=0;
        }                                         

/*****
	if(azscan_flag==1) {
	Az_cmd_rate=(az-az1)*milliarcsec;
	El_cmd_rate=0.;
	}

	if(elscan_flag==1) {
	El_cmd_rate=(el-el1)*milliarcsec;
	Az_cmd_rate=0.;
	}

	if((azscan_flag==1)&&(elscan_flag==1)) {
	Az_cmd_rate=(az-az1)*milliarcsec;
	El_cmd_rate=(el-el1)*milliarcsec;
	}
****/
	
	prev_azrate = azrate;
        prev_elrate = elrate;
                                 
	/* to detect the transit for a northern source */

/*
commented out on 23 sep 2002
	if ((hangle1 * hangle2 < 0.0) && (az1 < pi / 2.0))
	    azrate = azrate - 2.0 * pi;
*/

/*debug
printf("azrate=%f hangle1=%f hangle2=%f az1=%f\n", azrate,hangle1,hangle2,az1);
*/

	azint = az * milliarcsec;
	elint = el * milliarcsec;
	azrateint = azrate * milliarcsec;
	elrateint = elrate * milliarcsec;
	tjdint = (tjd - tjd0) * 24.0 * 3600.0 * 1000.0;
	az1 = az;
	el1 = el;
	hangle1 = hangle2;

/*debug
printf("%d %d %.12f %.12f %.12f %.12f %d %d\n",icount,milliseconds,(lst_radian*24*1800/pi),tjd,az*180./pi,el*180./pi,azrateint,elrateint);
*/

	/*
	 * converting cmd az,el and rates to counts, and adjusting these for
	 * the azimuth lap ambiguity
	 */


	Az_cmd = (double) azint;
	az_cmd = (int) Az_cmd;	

	El_cmd = (double) elint;
	el_cmd = (int) El_cmd;

	Az_cmd_rate = (double) azrateint;

	El_cmd_rate = (double) elrateint;

	/* check if servo is running */
	if((tsshm->msec)==checkmsec) {
	strcpy(messg,"servo is not running.");
	strcpy(lastCommand,"Servo is not running.");
	SendLastCommandToRM(lastCommand);
	}

	az_enc = tsshm->encAz;
        el_enc = tsshm->encEl;   
	az_actual=(double)az_enc/MSEC_PER_DEG;
        el_actual=(double)el_enc/MSEC_PER_DEG;


                                                  
	/* read subreflector x,y,z positions */

	el_actual_disp = el_actual-pmdel/3600.;
	az_actual_disp = az_actual-pmdaz/3600./cos(el_actual_disp*radian);

	az_actual_msec = az_actual_disp * 3600000.;
	el_actual_msec = el_actual_disp * 3600000.;


/* Bug:
*/
/* comment out the following ... now az can go negative if it has to
*/
/*
	if (az_actual_msec < 0.)
	    az_actual_msec += 1296000000.;
	if (az_actual_msec >= 1296000000.)
	    az_actual_msec -= 1296000000.;
*/


	az_actual_msec_int = (unsigned long) az_actual_msec;
	el_actual_msec_int = (unsigned long) el_actual_msec;


	/* now adjust az_cmd, if encoder has rolled over */
	/*
	 * The commanded azimuth in counts should not be a smaller number
	 * than the AZ_NEG_HARDSTOP_CTS which is the negative hardstop
	 */


/* Cable-wrap logic for command azimuth */
/*  -269.902 is the CCW prelimit from
the "settings" file  for the new servo, corresponding
to the az enc value for antenna-1 at Haystack */

/* changed the hardcoded limit numbers below for the
new style antennas, to values reported by servo through
shared memory */

if(antennaNumber==1)
{
if ((Az_cmd>=180.*MSEC_PER_DEG)&&
	(Az_cmd<=(tsshm->cwLimit))&&(az_actual < 90.)) 
			{Az_cmd -= (360.*MSEC_PER_DEG);
			az_disp-=(2*pi);
			}
if(Az_cmd < (tsshm->ccwLimit)) {Az_cmd += 360.*MSEC_PER_DEG;
			if(az_disp<0.) az_disp+=2*pi;}
}


if ((Az_cmd>=180.*MSEC_PER_DEG)&&
	(Az_cmd<=(tsshm->cwLimit))&&(az_actual < 90.)) 
			{Az_cmd -= (360.*MSEC_PER_DEG);
			az_disp-=(2*pi);
			}
if(Az_cmd < (tsshm->ccwLimit)) {Az_cmd += 360.*MSEC_PER_DEG;
			if(az_disp<0.) az_disp+=2*pi;}

	/* check for sun avoidance w.r.t actual position */

#if 0
if(sunel>(5.*radian)) {
if(sunDistance(az_actual_disp*radian,el_actual_disp*radian,sunaz,sunel)<=SUNLIMIT)
	{
	    if(sun_avoid_flag==0)
	    {

		strcpy(lastCommand,"Sun limit: Avoiding the Sun");
		SendLastCommandToRM(lastCommand);
            	strcpy(messg, "Sun limit:  Avoiding the Sun.");
		SendMessageToRM(messg);
		/* added M3 opening  27 Jan 2003 */
		
		/* removing M3 control - 26 sep 2005 */
	
		/*
		if(m3StateSetFlag==0) {
			m3StatePrev=m3State;
			m3StateSetFlag=1;
		}

		tsshm->m3Cmd=CLOSE_M3_CMD;
		*/

		 if((sunel/radian)>(SUNLIMIT+11.)) suneloff=-SUNLIMIT*3600/2;
              	 if((sunel/radian)<=(SUNLIMIT+11.)) suneloff=SUNLIMIT*3600/2;

	      sun_avoid_flag=1;
	    }

	 } else {
	     if(sun_avoid_flag==1)
	     {
		strcpy(lastCommand,"Out of Sun limit: resuming.");
		SendLastCommandToRM(lastCommand);
            	strcpy(messg, "Out of Sun limit: resuming.");
		SendMessageToRM(messg);
		/* added M3 opening  27 Jan 2003 */
	
		/* open m3 only if it was already open before 
		entering sun-zone 
		if(m3StatePrev!=1) {
			tsshm->m3Cmd=OPEN_M3_CMD;
			m3StateSetFlag=0;
		}
		*/

	     sun_avoid_flag=0;
	     }
	} /* sun limit check  with actual position */
}
#endif
/* removed sunavoidance check from Track 26 sep 2005. */

/*
printf("el_cmd=%d suneloff=%d \n",el_cmd,(int)suneloff);
*/

	

	/*********************************************************/

/* getting az and el tracking errors from shared memory */
/* in mas */

        az_error = (tsshm->azTrError)/MSEC_PER_DEG;
        el_error = (tsshm->elTrError)/MSEC_PER_DEG;
                                                         

/* correct the azimuth tracking error for cosine elevation */
	az_error = az_error * cos(el);

	posn_error = pow(((double) az_error * (double) az_error + (double) el_error * (double) el_error), 0.5);

	/* pass tracking errors through reflective memory */
	
        az_tracking_error=(float)az_error *3600.;
        el_tracking_error=(float)el_error *3600.;


/* commenting these out since bob now writes these from servo, 17 jul01
	rm_status=rm_write(RM_ANT_0,
		"RM_AZ_TRACKING_ERROR_F",&az_tracking_error);

	rm_status=rm_write(RM_ANT_0,
		"RM_EL_TRACKING_ERROR_F",&el_tracking_error);
*/

/*********** compute the running average of tracking errors (c. katz)*****/


	tracking_error = sqrt((az_error * 3600.) * (az_error * 3600.)
			      + (el_error * 3600.) * (el_error * 3600.));
	tracking_error_accum -= *dp;
	tracking_error_accum += tracking_error;
	*dp = tracking_error;
	dp++;
	if ((dp - tracking_error_buffer) > (SMOOTH_LENGTH - 1))
	    dp = tracking_error_buffer;
	smoothed_tracking_error = tracking_error_accum / SMOOTH_LENGTH;
   /* write smoothed tracking error to RM */ 
/* commenting out since Bob now writes these from servo 17 jul01 */
/*
        rm_status=rm_write(RM_ANT_0,"RM_TRACKING_ERROR_ARCSEC_D"
                                ,&smoothed_tracking_error);
*/


	if ((smoothed_tracking_error<18000.)&&(smoothed_tracking_error > 10.) && (pmac_comm == 1))
	{
	if(beep_flag==1) printf("");
	}
	
	if(smoothed_tracking_error>=10) waitflag=1;
	else waitflag=0;


/***************************spectrometer part****************************/
	/* Pass flag to Charlie's spectrometer program for tracking_OK */

	if (smoothed_tracking_error > 10.)
	    source_on_off_flag = INVALID;

	else if (previous_source_on_off_flag == INVALID)

	{

	    if (on_source == 1)
	    {
		source_on_off_flag = ONSOURCE;
		on_source_timer = integration * 10;
	    }
	    if (off_source == 1)
	    {
		source_on_off_flag = OFFSOURCE;
		off_source_timer = integration * 10;
	    }
	}

	/*
	 * if Charlie's program is alive, send an interrupt to inform about
	 * the above flag changes
	 */
	/* first check if the spectrometer program is alive */
	rm_status=rm_read(RM_ANT_0,"RM_SPECTROMETER_ANTENNA_S", 
			&spectrometer);
	/* if it is, then send interrupt */
/*
	if ((spectrometer == ENABLED) && (previous_source_on_off_flag != source_on_off_flag))
*/
	if (previous_source_on_off_flag != source_on_off_flag)
	{
	rm_status=rm_write_notify(RM_ANT_0,"RM_BLANKING_SOURCE_S",
				&source_on_off_flag);
/*
	    spectrometer = DISABLED;
*/
	    send_spectrometer_interrupt = 0;
/*
	    dummyint=DISABLED;
	    rm_status=rm_write(RM_ANT_0,"RM_SPECTROMETER_ANTENNA_S"
				,&dummyint);
*/
/*
	fprintf(stderr,"%.1f %.1f sending interrupt.\n",az_error*3600.,el_error*3600.);
*/
	}
	previous_source_on_off_flag = source_on_off_flag;

/******************************end of spectrometer part********************/

/************************* motion control ****************************/
/*
 * If scbComm = 1, then command motion through SCB else just
 * display the calculated and monitored values
 */

        if (scbComm == 1)
        {
                /* load the position and rate and turn on the drives */

                if(servoOnFlag==0)
                {
                tsshm->elCmd = ON_CMD;                    
                tsshm->azCmd = ON_CMD;
/*
		tsshm->msecCmd = tsshm->msec;
*/
 		servoOnFlag=1;
                }

	if((azelCommandFlag==1)&&(azscan_flag==0))
	{
	Az_cmd_rate=0.;
	}
	if((azelCommandFlag==1)&&(elscan_flag==0))
	{
	El_cmd_rate=0.;
	}

/*
	if(azscan_flag==1)
	{
	Az_cmd_rate=scan_unit*TIME_STEP*1000.;
	Az_cmd_rate/=cos(el);
	El_cmd_rate=0.;
	}

	if(elscan_flag==1)
	{
	El_cmd_rate=scan_unit*TIME_STEP*1000.;
	Az_cmd_rate=0.;
	}

	if((azscan_flag==1)&&(elscan_flag==1))
	{
	Az_cmd_rate=scan_unit*TIME_STEP*1000./cos(el);
	El_cmd_rate=scan_unit*TIME_STEP*1000.;
	}
*/

	servomilliseconds=tsshm->msec;

	/* check for bad values of position*/
	if(Az_cmd < (tsshm->ccwLimit)) Az_cmd+=(360.*MSEC_PER_DEG);
	if(Az_cmd > (tsshm->cwLimit)) Az_cmd-=(360.*MSEC_PER_DEG);


/* commented out on 23 oct 2002
	if ((El_cmd < (tsshm->lowerLimit)) ||
		(El_cmd > (tsshm->upperLimit))) {
            strcpy(messg,"Commanded elevation is beyond the limit.");
            SendMessageToRM(messg);
            interrupt_command_flag=1;
            user=64; 
	} 
	else {
*/
                tsshm->az = Az_cmd;
                tsshm->azVel = Az_cmd_rate;

/* added on 18 apr 2003 */
if(sun_avoid_flag==1) {
	if(suneloff>0.) El_cmd=HIGH_EL_TO_AVOID_SUN_MAS;
	if(suneloff<0.) El_cmd=LOW_EL_TO_AVOID_SUN_MAS;
	El_cmd_rate=0.;
}
                tsshm->el = El_cmd;
                tsshm->elVel = El_cmd_rate;
/*
	     }
*/
        tsshm->msecCmd = milliseconds;
        } /* if scbcomm=1 */
/****************************end of motion control*********************/

   
	/* Now reading tiltmeters as written by tiltRM */
	rm_status=rm_read(RM_ANT_0,"RM_TILT_VOLTS_V4_F",&tilt);	

	tilt[0]=tilt[0]/2.0;
	tilt[1]=tilt[1]/2.0; /* differential vs single-ended*/

	tiltx = (double) tilt[0] * SCALE_FACTOR_TILT1;/* convert to arseconds */
	tilty = (double) tilt[1] * SCALE_FACTOR_TILT2;
	tiltxbase = (double) tilt[2] * SCALE_FACTOR_TILT1;
        tiltybase = (double) tilt[3] * SCALE_FACTOR_TILT2;

	/* reading the new scaled tiltmeter values written
	   by logTilts (new version as of 15 Aug 2005) */

	rm_status=rm_read(RM_ANT_0,
	     "RM_AFT_FOREWARD_TILT_UPPER_ARCSEC_D",&scaledTiltx);
	rm_status=rm_read(RM_ANT_0,
	     "RM_LEFT_RIGHT_TILT_UPPER_ARCSEC_D",&scaledTilty);
if(tiltflag==1)
printf("scaledTiltx=%f scaledTilty = %f before gravity correction\n",
		scaledTiltx,scaledTilty);

	/* Now correct the scaled tiltmeter readings for local
	gravity vector */
	scaledTiltx = scaledTiltx - 20.665*cos(az_actual_disp*radian-2.941);
	scaledTilty = scaledTilty - 20.665*sin(az_actual_disp*radian-2.941);

if(tiltflag==1)
printf("scaledTiltx=%f scaledTilty = %f after gravity correction\n",
		scaledTiltx,scaledTilty);

/*
printf("scaledTiltx=%f scaledTilty=%f\n",scaledTiltx,scaledTilty);
*/

	/* write back tiltmeter readings in arcseconds to RM */
	rm_status=rm_write(RM_ANT_0,"RM_TILTX_ARCSEC_D",&tiltx);
	rm_status=rm_write(RM_ANT_0,"RM_TILTY_ARCSEC_D",&tilty);

	/* also write tiltmeter dc values in arcseconds to RM */
	rm_status=rm_write(RM_ANT_0,"RM_TILT_COEFFICIENTS_V6_D",&tiltCoefficients);
	rm_status=rm_write(RM_ANT_0,"RM_TILT_AZOFF_ARCSEC_D",&tiltAzoffCorrection);
	rm_status=rm_write(RM_ANT_0,"RM_TILT_ELOFF_ARCSEC_D",&tiltEloffCorrection);
	

	/************************************************************/


	/* displaying everything */

	if (icount == 1)
	    initflag = 0;
	if (icount != 1)
	    initflag = 1;

	azoff_int=(short)azoff;
	eloff_int=(short)eloff;
	rm_status=rm_write(RM_ANT_0,"RM_AZOFF_D",&azoff);
	rm_status=rm_write(RM_ANT_0,"RM_ELOFF_D",&eloff);
/*
	rm_status=rm_write(RM_ANT_0,"RM_RAOFF_ARCSEC_D",&raOffset);
	rm_status=rm_write(RM_ANT_0,"RM_DECOFF_ARCSEC_D",&decOffset);
*/
	/* latching values of azoff and eloff with total power volts
		for the chart program */
	rm_status=rm_write(RM_ANT_0,"RM_CHART_AZOFF_ARCSEC_D",&azoff);
	rm_status=rm_write(RM_ANT_0,"RM_CHART_ELOFF_ARCSEC_D",&eloff);
	rm_status=rm_read(RM_ANT_0,"RM_TOTAL_POWER_VOLTS_D",&dummyDouble);
        chartTotalPowerVolts[0]=dummyDouble;
	rm_status=rm_read(RM_ANT_0,"RM_TOTAL_POWER_VOLTS2_D",&dummyDouble);
        chartTotalPowerVolts[1]=dummyDouble;
	rm_status=rm_read(RM_ANT_0,"RM_CONT1_DET1_F",&dummyFloat);
        chartTotalPowerVolts[2]=(double)dummyFloat;
	rm_status=rm_read(RM_ANT_0,"RM_CONT1_DET2_F",&dummyFloat);
        chartTotalPowerVolts[3]=(double)dummyFloat;
	rm_status=rm_read(RM_ANT_0,"RM_CONT2_DET1_F",&dummyFloat);
        chartTotalPowerVolts[4]=(double)dummyFloat;
	rm_status=rm_read(RM_ANT_0,"RM_CONT2_DET2_F",&dummyFloat);
        chartTotalPowerVolts[5]=(double)dummyFloat;
	rm_status=rm_read(RM_ANT_0,"RM_SYNCDET_CHANNELS_V2_D",&syncdetChannels);
	chartSyncdetVolts[0]=syncdetChannels[0];
	chartSyncdetVolts[1]=syncdetChannels[1];
	chartSyncdetVolts[2]=0.;
	chartSyncdetVolts[3]=0.;
	chartSyncdetVolts[4]=0.;
	chartSyncdetVolts[5]=0.;
	rm_status=rm_write(RM_ANT_0,"RM_CHART_SYNCDET_VOLTS_V6_D",
			&chartSyncdetVolts);

	rm_status=rm_write(RM_ANT_0,"RM_CHART_TOTAL_POWER_VOLTS_V6_D",
		&chartTotalPowerVolts);

	/* fill in the RM variables for ccd header info if optical mode*/
	time1 = time(NULL);
        tval = localtime(&time1);
        if(antennaNumber==1) strcpy(antdir,"ant1");
        if(antennaNumber==2) strcpy(antdir,"ant2");
        if(antennaNumber==3) strcpy(antdir,"ant3");
        if(antennaNumber==4) strcpy(antdir,"ant4");
        if(antennaNumber==5) strcpy(antdir,"ant5");
        if(antennaNumber==6) strcpy(antdir,"ant6");
        if(antennaNumber==7) strcpy(antdir,"ant7");
        if(antennaNumber==8) strcpy(antdir,"ant8");

	sprintf(snamefits, "/opticalPointing/%s/%s_%02d%02d%02d_%02d%02d%02d.fits", 
				antdir,sname2,
                                (tval->tm_year)+1900, tval->tm_mon + 1,
                                tval->tm_mday,
                                tval->tm_hour,
                                tval->tm_min,
                                tval->tm_sec);

	rm_status=rm_write(RM_ANT_0,"RM_CCD_FITS_FILENAME_C100",snamefits);
	if(rm_status != RM_SUCCESS) {
                rm_error_message(rm_status,"rm_write() filename");
                }

	rm_status=rm_write(RM_ANT_0,"RM_SPECTRAL_TYPE_C10",sptype);
	if(rm_status != RM_SUCCESS) {
                rm_error_message(rm_status,"rm_write() sptype");
                }
	rm_status=rm_write(RM_ANT_0,"RM_VISUAL_MAGNITUDE_F",&magnitude);
	if(rm_status != RM_SUCCESS) {
                rm_error_message(rm_status,"rm_write() magnitude");
                }


/*
if(interrupt_command_flag==0) user = getchar();
*/

	switch (user)
	{
	case 'q':
	strcpy(lastCommand,"Exit from Track");
	SendLastCommandToRM(lastCommand);



          if (scbComm == 1)
            {
                tsshm->azCmd = OFF_CMD;
                tsshm->elCmd = OFF_CMD;
/*
                tsshm->msecCmd = milliseconds;
*/
		scbComm = 0;
            }                   

          	rm_status=rm_clear_monitor();
                if(rm_status != RM_SUCCESS) {
                rm_error_message(rm_status,"rm_clear()");
                exit(1);
                }
	    fprintf(stderr,"\nReceived signal: %d. Exiting track. Bye.\n",
			receivedSignal);
	    if (receivedSignal==SIGINT) exit(0);
	    if (receivedSignal==SIGTERM) exit(QUIT_RTN);
		user = -1;
	    break;
	case '0':
	strcpy(lastCommand,"Reset offsets and  stop scans");
	SendLastCommandToRM(lastCommand);
	    azscan_flag = 0;
	    elscan_flag = 0;
	    azoff = 0.;
	    eloff = 0.;
	    az_offset_flag=1;
            el_offset_flag=1;     
	    strcpy(messg, "                                       ");
		SendMessageToRM(messg);
		user = -1;
	    break;

	case 'O':
	idleDrivesTimeout=0;
	strcpy(lastCommand,"Azoff from SMAsh");
	SendLastCommandToRM(lastCommand);
        rm_status=rm_read(RM_ANT_0,"RM_SMASH_AZOFF_ARCSEC_D",&azoff);
	az_offset_flag=1;
		user = -1;
	break;

/* ignore command '5', which is handled by the encoder-server
for holography mapping */

	case '5':
	radio_flag=1;
		user = -1;
	break;

	case '4':
	radio_flag=0;
		user = -1;
	break;

	case 'P':
	strcpy(lastCommand,"Eloff from SMAsh");
	SendLastCommandToRM(lastCommand);
        rm_status=rm_read(RM_ANT_0,"RM_SMASH_ELOFF_ARCSEC_D",&eloff);
        el_offset_flag=1;
		user = -1;
	break;

	case 'T':
	idleDrivesTimeout=0;
	idleDrivesTimeoutFlag=1;
	strcpy(lastCommand,"Az from SMAsh");
	SendLastCommandToRM(lastCommand);
        rm_status=rm_read(RM_ANT_0,"RM_SMARTS_AZ_DEG_F",&smarts_az);
        rm_status=rm_read(RM_ANT_0,"RM_SMARTS_EL_DEG_F",&smarts_el);
	azelCommandFlag=1;

		icount=0;
		interrupt_command_flag=0;
		commanded_az = (double)smarts_az;
		commanded_el = (double)smarts_el;
		target_flag = 1;
		user = -1;
		goto new_source;
	break;

	case 'U':
	strcpy(lastCommand,"Offset unit from SMAsh");
	SendLastCommandToRM(lastCommand);
        rm_status=rm_read(RM_ANT_0,"RM_SMARTS_OFFSET_UNIT_ARCSEC_S",&scan_unit_int);
	scan_unit=(double)scan_unit_int;
		user = -1;
	break;

	case 'i':
	strcpy(lastCommand,"Integration time from SMAsh");
	SendLastCommandToRM(lastCommand);
        rm_status=rm_read(RM_ANT_0,"RM_SMARTS_INTEGRATION_TIME_SEC_S",&integration_short);
	integration=(int)integration_short;
		user = -1;
	break;

/*
	case 'o':
	strcpy(lastCommand,"Open mirror door");
	SendLastCommandToRM(lastCommand);
                tsshm->m3Cmd = OPEN_M3_CMD;
		user = -1;
	    break;
	case 'c':
	strcpy(lastCommand,"Close mirror door");
	SendLastCommandToRM(lastCommand);
	strcpy(messg, "                                       ");
	SendMessageToRM(messg);
	strcpy(messg, "MIRROR DOOR CLOSED                     ");
	SendMessageToRM(messg);
		tsshm->m3Cmd = CLOSE_M3_CMD;
		user = -1;
	    break;
*/
	case 'f':
/* feed offset command */
        rm_status=rm_read(RM_ANT_0,"RM_FEED_L",&requestedFeed);
	if(requestedFeed==230) {
	setFeedOffsetA1=feedOffset230A1;
	setFeedOffsetA2=feedOffset230A2;
	}
	if(requestedFeed==345) {
	setFeedOffsetA1=feedOffset345A1;
	setFeedOffsetA2=feedOffset345A2;
	}
	if(requestedFeed==400) {
	setFeedOffsetA1=feedOffset400A1;
	setFeedOffsetA2=feedOffset400A2;
	}
	if(requestedFeed==690) {
	setFeedOffsetA1=feedOffset690A1;
	setFeedOffsetA2=feedOffset690A2;
	}

	rm_status=rm_write(RM_ANT_0,"RM_FEEDOFFSET_A1_ARCSEC_D",
		&setFeedOffsetA1);
	rm_status=rm_write(RM_ANT_0,"RM_FEEDOFFSET_A2_ARCSEC_D",
		&setFeedOffsetA2);
	break;

	case 'p':
	idleDrivesTimeout=0;
	strcpy(lastCommand,"Start position switching");
	SendLastCommandToRM(lastCommand);
	    position_switching_flag = 1;
	    off_source_timer = integration;
	    on_source_timer = integration ;
	    on_source = 1;
	    off_source = 0;
		user = -1;
	    break;

	case 'a':
	idleDrivesTimeout=0;
	strcpy(lastCommand,"Azimuth scan");
	SendLastCommandToRM(lastCommand);
	    azscan_flag = 1;
	    strcpy(messg, "                                       ");
		SendMessageToRM(messg);
	    strcpy(messg, "azimuth scan");
		SendMessageToRM(messg);
		user = -1;
	    break;
	case 'z':
	strcpy(lastCommand,"Stop az and el scans");
	SendLastCommandToRM(lastCommand);
/*
	    scan_unit = 0.;
*/
	    azscan_flag = 0;
	    elscan_flag = 0;
		user = -1;
	    break;
	case 'e':
	idleDrivesTimeout=0;
	strcpy(lastCommand,"Elevation scan");
	SendLastCommandToRM(lastCommand);
	    elscan_flag = 1;
	    strcpy(messg, "                                       ");
		SendMessageToRM(messg);
	    strcpy(messg, "elevation scan");
		SendMessageToRM(messg);
		user = -1;
	    break;

	case '7':
	strcpy(lastCommand,"Azoff by minus chopper beam");
	SendLastCommandToRM(lastCommand);
	    azoff = azoff - CHOPPER_BEAM ;
		user = -1;
	    break;
	case '9':
	strcpy(lastCommand,"Azoff by plus chopper beam");
	SendLastCommandToRM(lastCommand);
	    azoff = azoff + CHOPPER_BEAM ;
		user = -1;
	    break;

	case 'r':
	case 'R':
	strcpy(lastCommand,"Reset azoff and eloff");
	SendLastCommandToRM(lastCommand);
	    azoff = 0.0;
	    eloff = 0.0;
	    az_offset_flag=1;
	    el_offset_flag=1;
		user = -1;
	    break;

	case 's':
	case 'S':
		user = -1;
	break;

	/* adding a command for ra-dec offsets */
	case '1':
	strcpy(lastCommand,"Adding ra/dec offset");
	SendLastCommandToRM(lastCommand);
	rm_status=rm_read(RM_ANT_0,"RM_RAOFF_ARCSEC_D",&raOffset);
	rm_status=rm_read(RM_ANT_0,"RM_DECOFF_ARCSEC_D",&decOffset);
		icount=0;
		if(target_flag==1) target_flag=0;
		interrupt_command_flag=0;
	        if(errorflag==ERROR) errorflag=OK;
		radec_offset_flag=1;
		user = -1;
		goto new_source;

	    break;
	
	case 'n':
	az_offset_flag=1;
	el_offset_flag=1;
	strcpy(lastCommand,"Change source");
	SendLastCommandToRM(lastCommand);
	rm_status=rm_read(RM_ANT_0,"RM_SMARTS_SOURCE_LENGTH_S",&slength);

	rm_status=rm_read(RM_ANT_0,"RM_SMARTS_SOURCE_C34", sname);
	azelCommandFlag=0;

	rm_status=rm_read(RM_ANT_0,"RM_CMD_SOURCE_FLAG_L", &newSourceFlag);
	if(newSourceFlag==1) sol_sys_flag=0;

		icount=0;
		if(target_flag==1) target_flag=0;
		interrupt_command_flag=0;
	        if(errorflag==ERROR) errorflag=OK;
		user = -1;
		goto new_source;

	    break;

	case '@':
	strcpy(lastCommand,"Standby - put track in simulation mode");
	SendLastCommandToRM(lastCommand);
	
	    if(scbComm==1)
            {
            position_switching_flag = 0;
            strcpy(messg, "Standing by.                           ");
            tsshm->azCmd = OFF_CMD;
            tsshm->elCmd = OFF_CMD;
/*
            tsshm->msecCmd = milliseconds;
*/
            scbComm=0;
	    servoOnFlag=0;
            }            

		user = -1;
	    break;

	case '!':
	/* if target mode, then start timer for idle drives*/
	if(target_flag==1) idleDrivesTimeoutFlag=1;
	strcpy(lastCommand,"Resume - put track in real mode");
	SendLastCommandToRM(lastCommand);
	    if(scbComm==0)
	    {
		icount=0;
		scbComm = 1;
            strcpy(messg, " Resuming 				       ");
		SendMessageToRM(messg);
		user = -1;
		goto beginning;
	    }
	    break;

	case 't':
	strcpy(lastCommand,"Start recording tiltmeter readings");
	SendLastCommandToRM(lastCommand);
	if (tilt_record_flag==0) tilt_record_flag=1;

sprintf(tiltfilename,"/data/engineering/tilt/tiltdata.ant%d",antennaNumber);
    fp_tilt = fopen(tiltfilename, "w");/* open file for tilt data logging  */
	if(fp_tilt==NULL) {
        fprintf(stderr,"Track failed to open tilt data file to write to.\n");
        }

		user = -1;
	break;

	case 'v':
	strcpy(lastCommand,"Stop recording tiltmeter readings");
	SendLastCommandToRM(lastCommand);
	if (tilt_record_flag==1) tilt_record_flag=0;
	fclose(fp_tilt);
		user = -1;
	break;

	case '(':
	strcpy(lastCommand,"Enable real-time tiltmeter corrections");
	SendLastCommandToRM(lastCommand);
	tiltflag=1;
		user = -1;
	break;

	case ')':
	strcpy(lastCommand,"Disable real-time tiltmeter corrections");
	SendLastCommandToRM(lastCommand);
	tiltflag=0;
		user = -1;
	break;

	case ';':
	if(beep_flag==1) {
	beep_flag=0;
	strcpy(lastCommand,"Turning off beeping");
	SendLastCommandToRM(lastCommand);
		user = -1;
	break;
	}
	if(beep_flag==0) {
	beep_flag=1;
	strcpy(lastCommand,"Turning on beeping");
	SendLastCommandToRM(lastCommand);
	}
		user = -1;
	break;
	
	case ':':
	tuneCommandFlag=2;
	strcpy(lastCommand,"CalWheel in Sky position");
	SendLastCommandToRM(lastCommand);
		user = -1;
	break;

	case '/':
	tuneCommandFlag=1;
	strcpy(lastCommand,"CalWheel in AmbientLoad position");
	SendLastCommandToRM(lastCommand);
		user = -1;
	break;

	    
	}			/* end of switch */

	interrupt_command_flag=0;


#if DEBUG
	printf("source=%s\n", sname);
	printf("lst=%lf\n", lst_disp);
	printf("utc=%lf\n", utc_disp);
	printf("tjd=%d\n", tjd_disp);
	printf("ra=%lf\n", ra_disp);
	printf("dec=%lf\n", dec_disp);
	printf("ra0=%lf\n", ra0);
	printf("dec0=%lf\n", dec0);
	printf("radot=%lf\n", radot);
	printf("decdot=%lf\n", decdot);
	printf("target_flag=%d\n", target_flag);
	printf("icount=%d\n", icount);
	printf("ra_cat=%lf\n", ra_cat_disp);
	printf("dec_cat=%lf\n", dec_cat_disp);
	printf("az_disp=%lf\n", az_disp);
	printf("el_disp=%lf\n", el_disp);
	printf("temperature=%f\n",temperature);
	printf("humidity=%f\n",humidity);
	printf("pressure=%f\n",pressure);
	printf("refraction=%f\n",refraction);
#endif


/* transfer hour-angle and declination through refl.mem. (RPC)*/

#if COORDINATES_SVC
	hourangle=lst_disp - ra_disp;

	rm_status=rm_write(RM_ANT_0,"RM_HOUR_ANGLE_HR_D", &hourangle);
	rm_status=rm_write(RM_ANT_0,"RM_RA_APP_HR_D", &ra_disp);
	rm_status=rm_write(RM_ANT_0,"RM_DEC_APP_DEG_D",&dec_disp);
	rm_status=rm_write(RM_ANT_0,"RM_UTC_HR_D", &utc_disp);
/* magnitude is actually velocity in this single dish version- in case
we are observing sources other than stars for optical pointing */
        if(sol_sys_flag==0) dummyDouble=sourceVelocity;
        if(sol_sys_flag==1) {
                dummyDouble=radialVelocity;
                magnitude=(float)radialVelocity;
                }
	rm_status=rm_write(RM_ANT_0,"RM_SVEL_KMPS_D",&dummyDouble);
	if(sol_sys_flag==0) dummyshortint=0x1;
	if(sol_sys_flag==1) dummyshortint=0x2;
	rm_status=rm_write(RM_ANT_0,"RM_SVELTYPE_S",&dummyshortint);

	dummyDouble=LATITUDE_DEGREES;
	rm_status=rm_write(RM_ANT_0,"RM_LATITUDE_DEG_D", &dummyDouble);

	dummyDouble= LONGITUDE_DEGREES;
	rm_status=rm_write(RM_ANT_0,"RM_LONGITUDE_DEG_D",&dummyDouble);
	drefraction=(double)refraction;
	rm_status=rm_write(RM_ANT_0,"RM_REFRACTION_ARCSEC_D",&drefraction);
	if((drefraction<0.0)||(drefraction>4000.)) {
	  strcpy(operatorErrorMessage, "Refraction correction failed.");
	  sendOpMessage(OPMSG_WARNING, 10, 30, operatorErrorMessage);
	}

	/* pointing model in RM*/
	
	if(radio_flag==1) {
        rm_status=rm_write(RM_ANT_0,"RM_AZDC_ARCSEC_D", &razdc);
        rm_status=rm_write(RM_ANT_0,"RM_AZCOLLIMATION_ARCSEC_D", &razcol);
        rm_status=rm_write(RM_ANT_0,"RM_AZELAXISTILT_ARCSEC_D", &reltilt);
        rm_status=rm_write(RM_ANT_0,"RM_AZAZTILTSIN_ARCSEC_D", &raztilt_sin);
        rm_status=rm_write(RM_ANT_0,"RM_AZAZTILTCOS_ARCSEC_D", &raztilt_cos);
        rm_status=rm_write(RM_ANT_0,"RM_AZAZTILTSIN2_ARCSEC_D", &raztilt_sin2);
        rm_status=rm_write(RM_ANT_0,"RM_AZAZTILTCOS2_ARCSEC_D", &raztilt_cos2);
        rm_status=rm_write(RM_ANT_0,"RM_AZENCSIN_ARCSEC_D", &razenc_sin);
        rm_status=rm_write(RM_ANT_0,"RM_AZENCCOS_ARCSEC_D", &razenc_cos);
        rm_status=rm_write(RM_ANT_0,"RM_AZENCSIN2_ARCSEC_D", &razenc_sin2);
        rm_status=rm_write(RM_ANT_0,"RM_AZENCCOS2_ARCSEC_D", &razenc_cos2);
        rm_status=rm_write(RM_ANT_0,"RM_AZENCSIN3_ARCSEC_D", &razenc_sin3);
        rm_status=rm_write(RM_ANT_0,"RM_AZENCCOS3_ARCSEC_D", &razenc_cos3);
        rm_status=rm_write(RM_ANT_0,"RM_AZRMS_ARCSEC_D", &razmodelrms);
        rm_status=rm_write(RM_ANT_0,"RM_ELDC_ARCSEC_D", &reldc);
        rm_status=rm_write(RM_ANT_0,"RM_ELSAG_ARCSEC_D", &relsag);
        rm_status=rm_write(RM_ANT_0,"RM_ELAZTILTSIN_ARCSEC_D", &reaztilt_sin);
        rm_status=rm_write(RM_ANT_0,"RM_ELAZTILTCOS_ARCSEC_D", &reaztilt_cos);
        rm_status=rm_write(RM_ANT_0,"RM_ELAZTILTSIN2_ARCSEC_D", &reaztilt_sin2);
        rm_status=rm_write(RM_ANT_0,"RM_ELAZTILTCOS2_ARCSEC_D", &reaztilt_cos2);
        rm_status=rm_write(RM_ANT_0,"RM_ELRMS_ARCSEC_D", &relmodelrms);
        rm_status=rm_write(RM_ANT_0,"RM_MODELDATE_C10",rmodeldate);
	}
	if(radio_flag==0) {
        rm_status=rm_write(RM_ANT_0,"RM_AZDC_ARCSEC_D", &azdc);
        rm_status=rm_write(RM_ANT_0,"RM_AZCOLLIMATION_ARCSEC_D", &azcol);
        rm_status=rm_write(RM_ANT_0,"RM_AZELAXISTILT_ARCSEC_D", &eltilt);
        rm_status=rm_write(RM_ANT_0,"RM_AZAZTILTSIN_ARCSEC_D", &aztilt_sin);
        rm_status=rm_write(RM_ANT_0,"RM_AZAZTILTCOS_ARCSEC_D", &aztilt_cos);
        rm_status=rm_write(RM_ANT_0,"RM_AZAZTILTSIN2_ARCSEC_D", &aztilt_sin2);
        rm_status=rm_write(RM_ANT_0,"RM_AZAZTILTCOS2_ARCSEC_D", &aztilt_cos2);
        rm_status=rm_write(RM_ANT_0,"RM_AZENCSIN_ARCSEC_D", &azenc_sin);
        rm_status=rm_write(RM_ANT_0,"RM_AZENCCOS_ARCSEC_D", &azenc_cos);
        rm_status=rm_write(RM_ANT_0,"RM_AZENCSIN2_ARCSEC_D", &azenc_sin2);
        rm_status=rm_write(RM_ANT_0,"RM_AZENCCOS2_ARCSEC_D", &azenc_cos2);
        rm_status=rm_write(RM_ANT_0,"RM_AZENCSIN3_ARCSEC_D", &azenc_sin3);
        rm_status=rm_write(RM_ANT_0,"RM_AZENCCOS3_ARCSEC_D", &azenc_cos3);
        rm_status=rm_write(RM_ANT_0,"RM_AZRMS_ARCSEC_D", &azmodelrms);
        rm_status=rm_write(RM_ANT_0,"RM_ELDC_ARCSEC_D", &eldc);
        rm_status=rm_write(RM_ANT_0,"RM_ELSAG_ARCSEC_D", &elsag);
        rm_status=rm_write(RM_ANT_0,"RM_ELAZTILTSIN_ARCSEC_D", &eaztilt_sin);
        rm_status=rm_write(RM_ANT_0,"RM_ELAZTILTCOS_ARCSEC_D", &eaztilt_cos);
        rm_status=rm_write(RM_ANT_0,"RM_ELAZTILTSIN2_ARCSEC_D", &eaztilt_sin2);
        rm_status=rm_write(RM_ANT_0,"RM_ELAZTILTCOS2_ARCSEC_D", &eaztilt_cos2);
        rm_status=rm_write(RM_ANT_0,"RM_ELRMS_ARCSEC_D", &elmodelrms);
        rm_status=rm_write(RM_ANT_0,"RM_MODELDATE_C10",modeldate);
	}

#endif

/* Bug:
*/
/* allowing the az reading to be negative */
/*
	if(az_actual_disp>=360.) az_actual_corrected=az_actual_disp-360.;
	else az_actual_corrected=az_actual_disp;
*/
	az_actual_corrected=az_actual_disp;
	
	if(sol_sys_flag==1)  planetdistance=distance;
	if(sol_sys_flag==0) {
	planetdistance=0.0;
	planetdiameter=0.0;
	}

        rm_status=rm_write(RM_ANT_0,"RM_PLANET_DISTANCE_AU_D", &planetdistance);
        rm_status=rm_write(RM_ANT_0,"RM_PLANET_DIAMETER_ARCSEC_D",&planetdiameter);

	
/* communicate some of the above variables to others through reflective
memory for monitoring purposes (azoff and eloff already written out
to RM ealier */



	padid_disp=(short)padid;
/*
	rm_status=rm_write(RM_ANT_0,"RM_PAD_ID_S",&padid_disp);
*/

/*
	rm_status=rm_write(RM_ANT_0,"RM_CHOPPER_X_COUNTS_D",&subx_counts);
	rm_status=rm_write(RM_ANT_0,"RM_CHOPPER_Y_COUNTS_D",&suby_counts);
	rm_status=rm_write(RM_ANT_0,"RM_CHOPPER_Z_COUNTS_D",&focus_counts);
	rm_status=rm_write(RM_ANT_0,"RM_CHOPPER_TILT_COUNTS_D",&subtilt_counts);
*/
	 dummyByte=(char)radio_flag;
	rm_status=rm_write(RM_ANT_0,"RM_REFRACTION_RADIO_FLAG_B",&dummyByte);

	    ret = rm_status=rm_write(RM_ANT_0,"RM_SOURCE_C34",sname);

	lst_disp_float=(float)lst_disp;
	utc_disp_float=(float)utc_disp;
	rm_status=rm_write(RM_ANT_0,"RM_LST_HOURS_F",&lst_disp_float);
	rm_status=rm_write(RM_ANT_0,"RM_UTC_HOURS_F",&utc_disp_float);

	rm_status=rm_write(RM_ANT_0,"RM_TJD_D",&tjd_disp);

	dummyFloat=(float)ra_cat_disp;
	rm_status=rm_write(RM_ANT_0,"RM_RA_CAT_HOURS_F",&dummyFloat);
	dummyFloat=(float)dec_cat_disp;
	rm_status=rm_write(RM_ANT_0,"RM_DEC_CAT_DEG_F",&dummyFloat);

	rm_status=rm_write(RM_ANT_0,"RM_EPOCH_F",&epoch);

	el_actual_disp_rm=(float)el_actual_disp;
	az_actual_corrected_rm=(float)az_actual_corrected;
	rm_status=rm_write(RM_ANT_0,"RM_ACTUAL_AZ_DEG_F",&az_actual_corrected_rm);
	rm_status=rm_write(RM_ANT_0,"RM_PLS_AZ_DEG_F",&az_actual_corrected_rm);
	rm_status=rm_write(RM_ANT_0,"RM_ACTUAL_EL_DEG_F",&el_actual_disp_rm);
	rm_status=rm_write(RM_ANT_0,"RM_PMDAZ_F",&pmdaz);
	rm_status=rm_write(RM_ANT_0,"RM_PMDEL_F",&pmdel);

	if(tilt_record_flag==1)
	{
 	time1 = time(NULL);
        tval = localtime(&time1);
        sprintf(tilt_timestamp,"%02d%02d%02d_%02d%02d%02d",
                                (tval->tm_year)+1900,
                                tval->tm_mon + 1,
                                tval->tm_mday,
                                tval->tm_hour,
                                tval->tm_min,
                                tval->tm_sec);

if(fp_tilt != NULL)
fprintf(fp_tilt,
"%s %d %d %f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f\n",
		tilt_timestamp,antennaNumber,padid,utc_disp,az_actual_disp,
		el_actual_disp,tiltx,tilty,tiltxbase,tiltybase,sunazf,sunelf,
		ambient_load_temperature,temperature,windspeed, winddirection);
	}


	fflush(stdout);

	checkmsec=tsshm->msec; /* for checking if servo is running*/
/*
	if(target_flag==0) {
	disableDrivesFlag=1;
        rm_status=rm_write(RM_ANT_0,"RM_DRIVES_TIMEOUT_FLAG_S",&disableDrivesFlag);
	}
*/

        rm_status=rm_read(RM_ANT_0,"RM_DRIVES_TIMEOUT_FLAG_S",&disableDrivesFlag);

	/* idle Drives timer */
	if((tilt_record_flag!=1)&&(idleDrivesTimeoutFlag==1)) 
			idleDrivesTimeout++;
	if((idleDrivesTimeout>IDLE_DRIVES_TIMEOUT) &&
		(disableDrivesFlag==0)){
	strcpy(messg,"                                     ");
	strcpy(messg,"Standby - idleDrives timeout.");
        SendMessageToRM(messg);
	strcpy(lastCommand,"Standby");
        SendLastCommandToRM(lastCommand);

            if(scbComm==1)
            {
            position_switching_flag = 0;
            strcpy(messg, "Standing by.                           ");
            tsshm->azCmd = OFF_CMD;
            tsshm->elCmd = OFF_CMD;
/*
            tsshm->msecCmd = milliseconds;
*/
            scbComm=0;
            servoOnFlag=0;
            }
	idleDrivesTimeoutFlag=0;
	idleDrivesTimeout=0;
	}
	if(target_flag==0) {
	idleDrivesTimeout=0;
	idleDrivesTimeoutFlag=0;
	}

  /* timestamp for DERS etc..*/
        rm_status=rm_read(RM_ANT_0,"RM_UNIX_TIME_L",&timestamp);
        rm_status=rm_write(RM_ANT_0,"RM_TRACK_TIMESTAMP_L",&timestamp);

	/* update milliseconds to servo's shared memory 
        tsshm->msecCmd = milliseconds;
	*/
/*debug
fprintf(fp_debug, "%lf %lf %lf %lf %lf %lf %lf %lf\n",
tjd_disp,utc_disp,tsshm->limAz,tsshm->limEl,az_actual,el_actual,Az_cmd_rate,El_cmd_rate);
if(icount==1) 
fprintf(fp_debug, "tjd_disp utc_disp tsshm->msec tsshm->msecCmd milliseconds  tsshm->az  tsshm->el  tsshm->azVel  tsshm->elVel  scbComm  tsshm->azCmd tsshm->elCmd tsshm->azState tsshm->elState\n");
fprintf(fp_debug, "%lf %lf %d %d %d %lf %lf %lf %lf %d %d %d %d %d\n", tjd_disp,utc_disp,tsshm->msec,tsshm->msecCmd,milliseconds, tsshm->az, tsshm->el, tsshm->azVel, tsshm->elVel, scbComm, tsshm->azCmd,tsshm->elCmd,tsshm->azState,tsshm->elState);
*/

	sleep(1);
/*
    printf("idleDrivesTimeoutFlag=%d,idleDrivesTimeout=%d m3State=%d Prev=%d Flag=%d\n",
idleDrivesTimeoutFlag,idleDrivesTimeout,m3State,m3StatePrev,m3StateSetFlag);
*/
    }				/* this is the big while loop */


}				/* end of main Loop */

void
split(unsigned long * lw, unsigned short * sw1, unsigned short * sw2)
{
    *sw1 = *lw & 0xFFFF;
    *sw2 = (*lw & 0xFFF0000) / 0x10000;
}


/*------------name.c--------*/
void
print_upper(char *name)
{
    register int    t;

    for (t = 0; name[t]; ++t)
    {
	name[t] = tolower(name[t]);
	/*
	 * putchar (name[t]);
	 */

    }

}

void
pad(char *s, int length)
{
    int             l;

    l = strlen(s);
    while (l < length)
    {
	s[l] = ' ';
	l++;
    }

    s[l] = '\0';
}


/*
 * This table is to be extended as and when we acquire more ephemeris data
 * from JPL for other minor bodies
 */

void
is_planet(char *s, int *flag, int *id)
{
    if (!strcmp(s, "mercury             "))
    {
	*id = 1;
	*flag = 1;
    } else if (!strcmp(s, "venus               "))
    {
	*id = 2;
	*flag = 1;
    } else if (!strcmp(s, "earth               "))
    {
	*id = 3;
	*flag = 1;
    } else if (!strcmp(s, "mars                "))
    {
	*id = 4;
	*flag = 1;
    } else if (!strcmp(s, "jupiter             "))
    {
	*id = 5;
	*flag = 1;
    } else if (!strcmp(s, "saturn              "))
    {
	*id = 6;
	*flag = 1;
    } else if (!strcmp(s, "uranus              "))
    {
	*id = 7;
	*flag = 1;
    } else if (!strcmp(s, "neptune             "))
    {
	*id = 8;
	*flag = 1;
    } else if (!strcmp(s, "pluto               "))
    {
	*id = 9;
	*flag = 1;
    } else if (!strcmp(s, "moon                "))
    {
	*id = 301;
	*flag = 1;
    } else if (!strcmp(s, "sun                 "))
    {
	*id = 10;
	*flag = 1;
    } else if (!strcmp(s, "titan               "))
    {
	*id = 606;
	*flag = 1;
    } else if (!strcmp(s, "io                  "))
    {
	*id = 501;
	*flag = 1;
    } else if (!strcmp(s, "europa              "))
    {
	*id = 502;
	*flag = 1;
    } else if (!strcmp(s, "callisto            "))
    {
	*id = 504;
	*flag = 1;
    } else if (!strcmp(s, "ganymede            "))
    {
	*id = 503;
	*flag = 1;
    } else if (!strcmp(s, "mimas               "))
    {
	*id = 601;
	*flag = 1;
    } else if (!strcmp(s, "enceladus           "))
    {
	*id = 602;
	*flag = 1;
    } else if (!strcmp(s, "tethys              "))
    {
	*id = 603;
	*flag = 1;
    } else if (!strcmp(s, "dione               "))
    {
	*id = 604;
	*flag = 1;
    } else if (!strcmp(s, "rhea                "))
    {
	*id = 605;
	*flag = 1;
    } else if (!strcmp(s, "hyperion            "))
    {
	*id = 607;
	*flag = 1;
    } else if (!strcmp(s, "iapetus             "))
    {
	*id = 608;
	*flag = 1;
    } else if (!strcmp(s, "triton              "))
    {
	*id = 801;
	*flag = 1;
    } else if (!strcmp(s, "nereid              "))
    {
	*id = 802;
	*flag = 1;
    } else if (!strcmp(s, "ceres               "))
    {
        *id = 375;
        *flag = 1;
    } else if (!strcmp(s, "pallas              "))
    {
        *id = 376;
        *flag = 1;
    } else if (!strcmp(s, "hygiea              "))
    {
        *id = 377;
        *flag = 1;
    } else if (!strcmp(s, "vesta               "))
    {
	*id = 378;
	*flag = 1;
    } else
    {
	*id = 0;
	*flag = 0;
    }
}

/* The following function does the standard star catalog look up */

void
starcat(char *s, int *star_flag, struct source * observe_source)
{

    FILE           *fp2;

    int             end_of_file=0;

    int             number;

    int             rah, ram, decd, decm;

    float           vel, epoch, ras, decs, pmr, pmd;

    char            vtype[20], source_name[20], comment[100];
    char            decsign;

    *star_flag = 0;

	if(radio_flag==1) {
	fp2 = fopen("/global/catalogs/sma_catalog", "r");
        end_of_file = fscanf(fp2, 
	"%s %d %d %f %c%2d %d %f %f %f %f %s %f %s",
	 source_name, &rah, &ram, &ras, &decsign, &decd, &decm, &decs,
		    &pmr, &pmd, &epoch, vtype, &magnitude, comment);
	}

    	if(radio_flag==0) {
	fp2 = fopen("/global/catalogs/sma_optical_catalog", "r");
        end_of_file = fscanf(fp2, 
	"%d %s %d %d %f %c%2d %d %f %f %f %f %s %f %s %s",
	 &number,source_name, &rah, &ram, &ras, &decsign, &decd, &decm, &decs,
		    &pmr, &pmd, &epoch, vtype, &magnitude, comment,sptype);
	}

	
        while (end_of_file != EOF) {

	if(radio_flag==1) {
        end_of_file = fscanf(fp2, 
	"%s %d %d %f %c%2d %d %f %f %f %f %s %f %s",
	 source_name, &rah, &ram, &ras, &decsign, &decd, &decm, &decs,
		    &pmr, &pmd, &epoch, vtype, &magnitude, comment);
	}

    	if(radio_flag==0) {
        end_of_file = fscanf(fp2, 
	"%d %s %d %d %f %c%2d %d %f %f %f %f %s %f %s %s",
	 &number,source_name, &rah, &ram, &ras, &decsign, &decd, &decm, &decs,
		    &pmr, &pmd, &epoch, vtype, &magnitude, comment, sptype);
	}

	pad(source_name, 20);
	print_upper(source_name);

	if (!strcmp(s, source_name))
	{
	    *star_flag = 1;
	strcpy(observe_source->sourcename, source_name);
	observe_source->rah = rah;
	observe_source->ram = ram;
	observe_source->ras = ras;
	observe_source->decsign = decsign;
	observe_source->decd = decd;
	observe_source->decm = decm;
	observe_source->decs = decs;
	observe_source->pmr = pmr;
	observe_source->pmd = pmd;
	observe_source->epoch = epoch;
	strcpy(observe_source->veltype, vtype);
	observe_source->vel = magnitude;
	sourceVelocity=(double)magnitude;
	strcpy(observe_source->comment, comment);
	strcpy(messg, " ");
	break;
	}
	if(radio_flag==1) {
        if (end_of_file!=14) {
	strcpy(messg, "Source catalog is corrupted. ");
        SendMessageToRM(messg);
	fprintf(stderr,"%s\n",messg);
	strcpy(operatorErrorMessage, "Source catalog is corrupted.");
	  sendOpMessage(OPMSG_WARNING, 10, 30, operatorErrorMessage);
        break;
         }}
	if(radio_flag==0) {
        if (end_of_file!=16) {
	strcpy(messg, "Source catalog is corrupted. ");
        SendMessageToRM(messg);
	fprintf(stderr,"%s\n",messg);
	strcpy(operatorErrorMessage, "Source catalog is corrupted.");
	  sendOpMessage(OPMSG_WARNING, 10, 30, operatorErrorMessage);
        break;
         }}

        end_of_file=0;
    }
    fclose(fp2);
}

int pmac(char *command)
{
 
        char  response[159], response_lsbyte, response_msbyte;
        unsigned short word,i,comlen,reslen,pmac_flag;
        unsigned long itime;
        short j,repeat_read_flag;
	char  messg[100];
 
        comlen=strlen(command);
        command[comlen]='\0';
 
        /* clear the flag registers */
    *(pmac_ptr+HOST_FLAG_OFFSET/2)=0x0;
        *(pmac_ptr+PMAC_FLAG_OFFSET/2)=0x0;
 
        for(i=0;i<79;i++)
        {
        *(pmac_ptr+PMAC_STRING_OFFSET/2+i)=0x0;
        *(pmac_ptr+HOST_STRING_OFFSET/2+i)=0x0;
        }
 
                j=0;
 
                for(i=0;i<comlen;i=i+2)
                {
                        word=command[i]+command[i+1]*256;
                        *(pmac_ptr+HOST_STRING_OFFSET/2+j)=word;
                        j++;
                }
 
                if((comlen%2)==0) 
                *(pmac_ptr+HOST_STRING_OFFSET/2+strlen(command))=0x0;
 
	 /* set HOST flag to 0x1 */
 
        *(pmac_ptr+HOST_FLAG_OFFSET/2)=0x1;
 
 
        repeat_read_flag=1;
 
        while(repeat_read_flag==1)
        {
 
        /* poll for PMAC to set flag */
 
                itime=0;
                while(*(pmac_ptr+PMAC_FLAG_OFFSET/2)==0x0) 
                {
                        usleep(100);
                        itime++;
                        if(itime>1000)
                                {
			strcpy(messg,"PMAC Timed out.");
				SendMessageToRM(messg);
				return(-1);
                                }
                }
 
                pmac_flag=*(pmac_ptr+PMAC_FLAG_OFFSET/2);
 
                if((pmac_flag&0xf000)==0x8) return (pmac_flag&0xfff); 
 
                if((pmac_flag&0xff)==0xd) 
                {
                
                repeat_read_flag=1;
 
                reslen=*(pmac_ptr+PMAC_STRING_LENGTH_OFFSET/2);
 
 	        reslen=(unsigned short)ceil((double)reslen/2.);
        
                j=0;
                for(i=0;i<reslen;i++)
                {
                        word=*(pmac_ptr+PMAC_STRING_OFFSET/2+i);
                        response_lsbyte=word&0xff;
                        response_msbyte=(word&0xff00)/256;
                        response[j]=response_lsbyte;
                        response[j+1]=response_msbyte;
                        j=j+2;
                }
 
/*
                printf("%s\n",response);
*/
 
                *(pmac_ptr+PMAC_FLAG_OFFSET/2)=0x0;
                usleep(100);
                }
  if((pmac_flag&0xff)==0x6) repeat_read_flag=0;
        } 
return 0;
}

void SendMessageToRM(char *messg)
{
int messagelength;
char blank[100];
messagelength=strlen(messg);
sprintf(blank,"                                                                                                   ");                      
rm_status=rm_write(RM_ANT_0,"RM_TRACK_MESSAGE_C100",blank);
rm_status=rm_write(RM_ANT_0,"RM_TRACK_MESSAGE_C100",messg);
}

void SendLastCommandToRM(char *lastCommand)
{
int messagelength;
char blank[100];
messagelength=strlen(lastCommand);

sprintf(blank,"                                                                                                   ");                      
rm_status=rm_write(RM_ANT_0,"RM_TRACK_LAST_COMMAND_C100",blank);
rm_status=rm_write(RM_ANT_0,"RM_TRACK_LAST_COMMAND_C100",lastCommand);
}

double sunDistance(double az1,double el1,double az2,double el2)
{
double cosd,sind,d;

cosd=sin(el1)*sin(el2)+cos(el1)*cos(el2)*cos(az1-az2);
sind=pow((1.0-cosd*cosd),0.5);
d=atan2(sind,cosd);
d=d/radian;
return d;

}

/* Interrupt handler for receiving commands from SMARTS through 
reflective memory */

void *CommandHandler()
{
char command_test[30];
char name[RM_NAME_LENGTH];
int ant=RM_ANT_0;

	sprintf(name,"RM_SMARTS_PMAC_COMMAND_FLAG_S");

	while(1)
	{
	
	rm_status=rm_read_wait(&ant,name,&pmac_command_flag);
        if(rm_status != RM_SUCCESS) {
                rm_error_message(rm_status,"rm_read_wait()");
                exit(1);

        fprintf(stderr,"Interrupt received. pmac_command_flag=%d\n",pmac_command_flag);
	fflush(stderr);

	sleep(1);
	}
	
	/* if pmac_command_flag is 0, then this is a SMARTS command for
	   the tracker and not the PMAC */

	if(pmac_command_flag==0)
	{
	rm_status=rm_read(RM_ANT_0,"RM_SMASH_TRACK_COMMAND_C30",command_test);
        if(rm_status != RM_SUCCESS) {
                rm_error_message(rm_status,"rm_read()");
                exit(1);
        }

        user=(int)command_test[0];
	interrupt_command_flag=1;
	}

	} /* while */

	pthread_detach(&CommandHandlerTID);
	pthread_exit((void *) 0);
}

#if 0
void *CCDClient()
{
	char ccdhost[6];
	int ret;
	while(1)
	{
		if (acquireImageFlag==1)
		{
		if(antennaNumber==1) strcpy(ccdhost,"optel1");
		if(antennaNumber==2) strcpy(ccdhost,"optel2");
		if(antennaNumber==3) strcpy(ccdhost,"optel3");
		if(antennaNumber==4) strcpy(ccdhost,"optel4");
		if(antennaNumber==5) strcpy(ccdhost,"optel5");
		if(antennaNumber==6) strcpy(ccdhost,"optel6");
		if(antennaNumber==7) strcpy(ccdhost,"optel7");
		if(antennaNumber==8) strcpy(ccdhost,"optel8");
		ret=ccdprog_1(ccdhost);
		if(ret!=0) {
		fprintf(stderr,"Check if ccd program is running on optel%d\n",
			antennaNumber);
		fflush(stderr);
		}
		acquireImageFlag=0;
		}
		sleep(1);
	} 
	pthread_detach(&CCDClientTID);
	pthread_exit((void *) 0);
}
/* Now the image acquisition is handled by c90control on all optels */

int ccdprog_1(char* host)
{
        CLIENT *clnt;
        ccdCommand *ccdCommand, input;
        clnt = clnt_create(host, CCDCOMMANDPROG, CCDCOMMANDVERS, "tcp");
        if(clnt==NULL) {
        clnt_pcreateerror(host);
/* The following call was creating a segmentation fault if clnt==NULL.
   - 12 sep 2002
	clnt_perror(clnt,"clnt_create()");
*/
	return (-1);
        } else {
	input.acquireFlag=1;
        ccdCommand=ccdcommand_1(&input,clnt);
        clnt_destroy(clnt);
	}
	if(ccdCommand!=NULL) return(0);
	else return(-1);
}
#endif

void *tuneClient()
{
	CLIENT *cl;
	opticsRequest opticalRequest;
	char tunehost[6];
	int tuneClientCreateFlag;

		if(antennaNumber==1) strcpy(tunehost,"acc1");
		if(antennaNumber==2) strcpy(tunehost,"acc2");
		if(antennaNumber==3) strcpy(tunehost,"acc3");
		if(antennaNumber==4) strcpy(tunehost,"acc4");
		if(antennaNumber==5) strcpy(tunehost,"acc5");
		if(antennaNumber==6) strcpy(tunehost,"acc6");
		if(antennaNumber==7) strcpy(tunehost,"acc7");
		if(antennaNumber==8) strcpy(tunehost,"acc8");

	tuneClientCreateFlag=0;

	while(1)
	{
	/* if tunecommandflag is set, give the command and
	   reset the flag */

		if(tuneCommandFlag==1)
		{


		cal_flag=1;
		/* command for ambient load */
		opticalRequest.position = AMBIENT_IN;
		opticalRequest.device = OPTICS_MOTOR0;
		     /* checking if tune6 is running  else put warning*/
/*
		   if(tuneClientCreateFlag==0) {		
*/
	              cl = clnt_create(tunehost,TUNEPROG,TUNEVERS,"tcp");
	              if(cl == NULL) {
			clnt_pcreateerror(tunehost);
/*
			clnt_perror(cl,"clnt_create()");
*/
			strcpy(messg,"tune6 is not running.");
			strcpy(lastCommand,"tune6 is not running.");
			SendLastCommandToRM(lastCommand);
			fprintf(stderr,"tune6 is not running.\n");
			}
		  tuneClientCreateFlag=1;
/*
	          }
*/

		 if(cl!=NULL) {
		       reportOpticsResults(opticsrequest_1(&opticalRequest,cl));
			clnt_destroy(cl);
	         }
		}




		if(tuneCommandFlag==2)
		{

		cal_flag=0;
		/* command for sky */

	              cl = clnt_create(tunehost,TUNEPROG,TUNEVERS,"tcp");
	              if(cl==NULL) {
			clnt_pcreateerror(tunehost);
/*
			clnt_perror(cl,"clnt_create()");
*/
			strcpy(messg,"tune6 is not running.");
			strcpy(lastCommand,"tune6 is not running.");
			SendLastCommandToRM(lastCommand);
			fprintf(stderr,"tune6 is not running.\n");
			}
		opticalRequest.position = SKY_IN;
		opticalRequest.device = OPTICS_MOTOR0;
/*
		if((cl!=NULL)&&(tuneClientCreateFlag==1))
*/
		 if(cl!=NULL) {
		  reportOpticsResults(opticsrequest_1(&opticalRequest,cl));
			clnt_destroy(cl);
                  }
/*
		   if(tuneClientCreateFlag==1) {
*/
			tuneClientCreateFlag=0;
/*
		   }
*/
		}

		tuneCommandFlag=0;
	usleep(100000);
	} 
	pthread_detach(&tuneClientTID);
	pthread_exit((void *) 0);
}

void reportOpticsResults(opticsStatus *results)
{

   if (results == NULL) {
    fprintf(stderr,"RPC client timeout -- tune6 may be busy\n");
    return;
   }

                if(results->status==PALM_IN_CONTROL)
                {
                strcpy(messg,"Palm is in control");
                strcpy(lastCommand,"Palm is in control");
                SendLastCommandToRM(lastCommand);
                }

                if(results->finalPosition==AMBIENT_IN)
                {
                strcpy(messg,"Ambient load");
                strcpy(lastCommand,"Ambient load");
                SendLastCommandToRM(lastCommand);
                }

                if(results->finalPosition==SKY_IN)
                {
                strcpy(messg,"Blue sky");
                strcpy(lastCommand,"Blue sky");
                SendLastCommandToRM(lastCommand);
                }
}

void handlerForSIGINT(int signum)
{
        interrupt_command_flag=1;
        user='q'; /* 'q' for quit command */
	receivedSignal=signum;
        fprintf(stderr,"Got the control C signal:%d. Quitting.\n",signum);
}

double tjd2et(double tjd)
{
/*
  return((tjd-2451545.)* 86400.0+32.184+LEAPSECONDS+polar_dut);
*/
  return((tjd-2451545.)* 86400.0+32.184+LEAPSECONDS);
}

/*********************************end of track.c*************************/
